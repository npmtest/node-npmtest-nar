{"/home/travis/build/npmtest/node-npmtest-nar/test.js":"/* istanbul instrument in package npmtest_nar */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nar/lib.npmtest_nar.js":"/* istanbul instrument in package npmtest_nar */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nar = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nar = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nar/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nar && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nar */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nar\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nar.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nar.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nar.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nar.__dirname + '/lib.npmtest_nar.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/nar.js":"// Generated by LiveScript 1.3.1\nvar run, list, create, extract, install, download, createExec, version, exports;\nrun = require('./run');\nlist = require('./list');\ncreate = require('./create');\nextract = require('./extract');\ninstall = require('./install');\ndownload = require('./download');\ncreateExec = require('./create-exec');\nversion = require('../package.json').version;\nexports = module.exports = {\n  VERSION: version,\n  create: create,\n  createExec: createExec,\n  extract: extract,\n  run: run,\n  list: list,\n  install: install,\n  download: download,\n  get: download\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/run.js":"// Generated by LiveScript 1.3.1\nvar fw, utils, extract, download, join, spawn, EventEmitter, next, tmpdir, read, has, rm, delimiter, isWin, isArray, replaceEnvVars, isUrl, handleExit, hooksKeys, regexQuotes, regexSpaces, run, apply, readNarJson, getHooks, applyDefaultScriptHooks, mergeHooksArgs, mapHooks, isBinaryValid, exec, getCommandScript, parseCommand, parseFlags, cleanSpaces, setEnvironment, extendPath, slice$ = [].slice;\nfw = require('fw');\nutils = require('./utils');\nextract = require('./extract');\ndownload = require('./download');\njoin = require('path').join;\nspawn = require('child_process').spawn;\nEventEmitter = require('events').EventEmitter;\nnext = utils.next, tmpdir = utils.tmpdir, read = utils.read, has = utils.has, rm = utils.rm, delimiter = utils.delimiter, isWin = utils.isWin, isArray = utils.isArray, replaceEnvVars = utils.replaceEnvVars, isUrl = utils.isUrl, handleExit = utils.handleExit;\nhooksKeys = ['prestart', 'start', 'stop', 'poststop'];\nregexQuotes = /^[\\'\\\"]+|[\\'\\\"]+$/g;\nregexSpaces = /\\s+/g;\nmodule.exports = run = function(options){\n  var ref$, path, hooks, args, dest, clean, emitter, cleanDir, onError, onEntry, onArchive, onProgress, onDownloadEnd, onEnd, onDownload, hooksFn, appRunner, extractArchive, downloadArchive, doExtract, e;\n  ref$ = options = apply(\n  options), path = ref$.path, hooks = ref$.hooks, args = ref$.args, dest = ref$.dest, clean = ref$.clean;\n  emitter = new EventEmitter;\n  cleanDir = function(){\n    try {\n      if (clean) {\n        return rm(dest);\n      }\n    } catch (e$) {}\n  };\n  onError = function(err, code, cmd){\n    cleanDir();\n    return emitter.emit('error', err, code, cmd);\n  };\n  onEntry = function(entry){\n    if (entry) {\n      return emitter.emit('entry', entry);\n    }\n  };\n  onArchive = function(archive){\n    if (archive) {\n      return emitter.emit('archive', archive);\n    }\n  };\n  onProgress = function(status){\n    return emitter.emit('progress', status);\n  };\n  onDownloadEnd = function(it){\n    return emitter.emit('downloadEnd', it);\n  };\n  onEnd = function(options, nar){\n    cleanDir();\n    return emitter.emit('end', options, nar);\n  };\n  onDownload = function(){\n    return emitter.emit(\n    'download');\n  };\n  hooksFn = function(nar){\n    var buf, addHookFn, addStartMainScript, hook, ref$, cmd, own$ = {}.hasOwnProperty;\n    buf = [];\n    addHookFn = function(cmd, hook){\n      if (args && has(args, hook) && args[hook]) {\n        cmd += ' ' + parseFlags(\n        isArray(\n        args[hook])\n          ? args[hook].join(' ')\n          : args[hook]);\n      }\n      return buf.push(\n      exec(emitter, cmd, dest, hook));\n    };\n    addStartMainScript = function(){\n      if (nar.manifest.main) {\n        return buf.push(\n        exec(emitter, \"node \" + (nar.manifest.main || ''), dest, 'start'));\n      }\n    };\n    for (hook in ref$ = getHooks(nar, args)) if (own$.call(ref$, hook)) {\n      cmd = ref$[hook];\n      if (hooks || (!hooks && hook === 'start')) {\n        addHookFn(cmd, hook);\n      }\n    }\n    if (!buf.length) {\n      addStartMainScript();\n    }\n    return buf;\n  };\n  appRunner = function(options){\n    var nar;\n    nar = readNarJson(\n    dest);\n    emitter.emit('info', nar);\n    setEnvironment(dest, nar.manifest);\n    if (nar.binary) {\n      extendPath(\n      dest);\n      if (!isBinaryValid(\n      nar)) {\n        return onError(\n        new Error('Unsupported binary platform or processor'));\n      }\n    }\n    return fw.series(hooksFn(\n    nar), function(err){\n      if (err) {\n        return onError(\n        err);\n      }\n      return onEnd(options, nar);\n    });\n  };\n  extractArchive = function(){\n    emitter.emit(\n    'extract');\n    return extract(\n    options).on('error', onError).on('entry', onEntry).on('archive', onArchive).on('end', appRunner);\n  };\n  downloadArchive = function(){\n    options.url = path;\n    return download(\n    options).on('download', onDownload).on('error', onError).on('progress', onProgress).on('end', function(it){\n      options.path = it;\n      onDownloadEnd(\n      it);\n      return extractArchive();\n    });\n  };\n  doExtract = function(){\n    return next(function(){\n      if (!path) {\n        return onError(\n        new Error('Required archive path option'));\n      }\n      handleExit(\n      cleanDir);\n      if (isUrl(\n      path)) {\n        return downloadArchive();\n      } else {\n        return extractArchive();\n      }\n    });\n  };\n  try {\n    doExtract();\n  } catch (e$) {\n    e = e$;\n    onError(\n    \"Cannot run the archive: \" + e);\n  }\n  return emitter;\n};\napply = function(options){\n  return {\n    gzip: true,\n    path: options.path,\n    args: options.args || {},\n    auth: options.auth,\n    proxy: options.proxy,\n    strictSSL: options.strictSSL,\n    dest: options.dest || tmpdir(\n    options.path),\n    clean: options.clean != null ? options.clean : true,\n    hooks: options.hooks != null ? options.hooks : true\n  };\n};\nreadNarJson = function(dest){\n  return read(\n  join(dest, '.nar.json'));\n};\ngetHooks = function(nar, args){\n  var hooks, scripts;\n  args == null && (args = {});\n  hooks = {};\n  scripts = nar.manifest.scripts || {};\n  applyDefaultScriptHooks(nar, scripts);\n  [scripts, args].forEach(mergeHooksArgs(\n  hooks));\n  return hooks;\n};\napplyDefaultScriptHooks = function(nar, scripts, args){\n  if (!scripts.start) {\n    return scripts.start = \"node \" + (nar.manifest.main || 'index'), scripts;\n  }\n};\nmergeHooksArgs = function(hooks){\n  return function(args){\n    args == null && (args = {});\n    return hooksKeys.filter(function(it){\n      return has(args, it);\n    }).filter(function(it){\n      return args[it];\n    }).forEach(mapHooks(hooks, args));\n  };\n};\nmapHooks = function(hooks, args){\n  return function(it){\n    if (!hooks[it]) {\n      return hooks[it] = args[it], hooks;\n    }\n  };\n};\nisBinaryValid = function(nar){\n  var ref$, platform, arch;\n  ref$ = nar.info, platform = ref$.platform, arch = ref$.arch;\n  return platform === process.platform && (arch === process.arch || (arch === 'ia32' && process.arch === 'x64'));\n};\nexec = function(emitter, command, cwd, hook){\n  return function(done){\n    var ref$, cmd, args, cmdStr, child;\n    ref$ = parseCommand(\n    getCommandScript(\n    command)), cmd = ref$.cmd, args = ref$.args;\n    emitter.emit('command', cmdStr = cmd + \" \" + args.join(' '), hook);\n    if (hook === 'start') {\n      emitter.emit('start', cmdStr);\n    }\n    if (process.env.PATH.indexOf(\"node_modules/.bin\") !== 0) {\n      process.env.PATH = \"node_modules/.bin\" + delimiter + process.env.PATH;\n    }\n    child = spawn(cmd, args, {\n      cwd: cwd,\n      env: process.env\n    });\n    child.stdout.on('data', function(it){\n      return emitter.emit('stdout', it.toString());\n    });\n    child.stderr.on('data', function(it){\n      return emitter.emit('stderr', it.toString());\n    });\n    child.on('error', (function(it){\n      return done(it);\n    }));\n    return child.on('exit', function(code){\n      if (code !== 0) {\n        return done(new Error(\"Command failed with exit code: \" + code), code, cmdStr);\n      } else {\n        emitter.emit('exit', code, hook);\n        return done();\n      }\n    });\n  };\n};\ngetCommandScript = function(cmd){\n  var script;\n  if (cmd === 'node' || /^node /.test(cmd)) {\n    script = join(__dirname, '../scripts', isWin ? 'node.bat' : 'node.sh');\n    if (!isWin) {\n      script = \"/usr/bin/env bash \" + script;\n    }\n    cmd = (script + \" \") + cmd.replace(/^node/, '');\n  }\n  return cmd;\n};\nparseCommand = function(cmd){\n  var ref$, args;\n  ref$ = cleanSpaces(\n  replaceEnvVars(\n  cmd)).split(' '), cmd = ref$[0], args = slice$.call(ref$, 1);\n  return {\n    cmd: cmd,\n    args: args\n  };\n};\nparseFlags = function(flags){\n  return (flags || '').trim().replace(regexQuotes, '').trim();\n};\ncleanSpaces = function(it){\n  return it.replace(regexSpaces, ' ');\n};\nsetEnvironment = function(dest, manifest){\n  manifest == null && (manifest = {});\n  process.env.NODE_PATH = join(dest, '.node');\n  process.env.NODE_NAR = '1';\n  process.env.npm_package_name = manifest.name || '';\n  return process.env.npm_package_version = manifest.version || '';\n};\nextendPath = function(dest){\n  return process.env.PATH = join(dest, '.node/bin') + (delimiter + \"\" + process.env.PATH);\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/utils.js":"// Generated by LiveScript 1.3.1\nvar fs, os, hu, path, crypto, status, Buffer, rm, mk, findup, normalize, join, dirname, basename, delimiter, extname, env, platform, exit, nextTick, arch, _;\nfs = require('fs');\nos = require('os');\nhu = require('hu');\npath = require('path');\ncrypto = require('crypto');\nstatus = require('./status');\nBuffer = require('buffer').Buffer;\nrm = require('rimraf');\nmk = require('mkdirp');\nfindup = require('findup-sync');\nnormalize = path.normalize, join = path.join, dirname = path.dirname, basename = path.basename, delimiter = path.delimiter, extname = path.extname;\nenv = process.env, platform = process.platform, exit = process.exit, nextTick = process.nextTick, arch = process.arch;\nmodule.exports = _ = {\n  path: path,\n  platform: platform,\n  arch: arch,\n  extend: hu.extend,\n  vals: hu.vals,\n  EOL: os.EOL,\n  clone: hu.clone,\n  isObject: hu.isObject,\n  isArray: hu.isArray,\n  isString: hu.isString,\n  has: hu.has,\n  delimiter: delimiter,\n  echo: function(it){\n    if (it) {\n      return console.log.apply(this, arguments);\n    } else {\n      return console.log('');\n    }\n  },\n  rm: rm.sync,\n  mk: mk.sync,\n  next: nextTick,\n  env: function(it){\n    return env[it] || null;\n  },\n  now: function(){\n    return Date.now();\n  },\n  isWin: platform === 'win32',\n  toKb: function(it){\n    if (it) {\n      return Math.round(it / 1024) || 1;\n    } else {\n      return 0;\n    }\n  },\n  exists: function(it){\n    return it && fs.existsSync(\n    normalize(\n    it));\n  },\n  stringify: function(it){\n    if (it) {\n      return JSON.stringify(it, null, 2);\n    }\n  },\n  resolvePkgPath: function(it){\n    if (_.isFile(\n    it)) {\n      return _.resolvePkgPath(\n      dirname(\n      it));\n    } else {\n      return it;\n    }\n  },\n  keys: function(it){\n    if (hu.isObject(\n    it)) {\n      return Object.keys(\n      it);\n    } else {\n      return [];\n    }\n  },\n  tmpdir: function(name){\n    name == null && (name = 'pkg');\n    name = basename(name, extname(\n    name));\n    return join(os.tmpdir(), \"nar-\" + name + \"-\" + _.random());\n  },\n  addExtension: function(it){\n    if (it && !_.isUrl(\n    it)) {\n      if (!/.nar$/.test(it)) {\n        it += '.nar';\n      }\n    }\n    return it;\n  },\n  isDir: function(it){\n    return _.exists(\n    it) && fs.lstatSync(\n    normalize(\n    it)).isDirectory();\n  },\n  isLink: function(it){\n    return fs.lstatSync(\n    normalize(\n    it)).isSymbolicLink();\n  },\n  isFile: function(it){\n    return _.exists(\n    it) && (fs.lstatSync(\n    normalize(\n    it)).isFile() || _.isLink(\n    it));\n  },\n  random: function(){\n    return _.now() + Math.floor(Math.random() * 10000);\n  },\n  lines: function(it){\n    if (it) {\n      return it.split(os.EOL);\n    }\n  },\n  isUrl: function(it){\n    return /^http[s]?\\:/.test(\n    it);\n  },\n  httpStatus: function(code){\n    if (code) {\n      return code + \" \" + (status[code] || '');\n    } else {\n      return '';\n    }\n  },\n  replaceEnvVars: function(str){\n    return str.replace(/\\$\\{(\\w+)\\}/ig, function(_, name){\n      return process.env[name] || '';\n    });\n  },\n  logError: function(err, debug){\n    if (err) {\n      if (debug && err.stack) {\n        return err.stack;\n      } else {\n        return (\"Error: \" + (err.message || err)).red;\n      }\n    }\n  },\n  exit: function(code){\n    if (code === 0 || !code) {\n      exit(\n      code);\n    }\n    return function(message){\n      if (message != null) {\n        if (String.prototype.red != null) {\n          message = message.red;\n        }\n        _.echo(\n        message);\n      }\n      return exit(\n      code);\n    };\n  },\n  read: function(it){\n    var data;\n    if (_.exists(\n    it)) {\n      data = fs.readFileSync(\n      normalize(\n      it)).toString();\n      if (/.json$/.test(\n      it)) {\n        return JSON.parse(\n        data);\n      } else {\n        return data;\n      }\n    } else {\n      return null;\n    }\n  },\n  write: function(path, data){\n    if (path) {\n      return fs.writeFileSync(path, data);\n    }\n  },\n  once: function(cb){\n    var error;\n    error = false;\n    return function(it){\n      if (!error) {\n        cb.apply(this, arguments);\n      }\n      if (it) {\n        return error = true;\n      }\n    };\n  },\n  discoverPkg: function(dir){\n    dir == null && (dir = process.cwd());\n    return findup('package.json', {\n      cwd: dir\n    });\n  },\n  handleExit: function(cb){\n    var listener;\n    listener = function(){\n      process.stdin.resume();\n      cb();\n      return process.removeListener('SIGINT', listener);\n    };\n    return process.on('SIGINT', listener);\n  },\n  isExecutable: function(path){\n    var buffer, num, data;\n    buffer = new Buffer(25);\n    num = fs.readSync(fs.openSync(path, 'r'), buffer, 0, 25, 0);\n    data = buffer.toString('utf-8', 0, num);\n    return /^\\#\\!\\/bin\\/bash/.test(data) && /\\#\\#nar\\#\\#/.test(data);\n  },\n  executableMsg: function(file){\n    file = basename(\n    file || 'sample.nar');\n    if (_.isWin) {\n      return \"the nar file is an executable, you cannot run it in Windows\";\n    } else {\n      return \"the nar file is an executable, you must run it as binary:\\n\\n  Example:\\n  $ chmod +x \" + file + \"\\n  $ ./\" + file + \" exec --port 8080 --verbose\\n\\nYou could use the exec, start, extract, install or list commands\\nFor more usage information, see the docs at github.com/h2non/nar\";\n    }\n  },\n  archiveName: function(nar){\n    var name, version;\n    name = '';\n    if (nar) {\n      name += nar.name || 'unnamed';\n      if (version = nar.manifest.version) {\n        name += \"-\" + version;\n      }\n      if (nar.binary) {\n        name += \"-\" + platform + \"-\" + arch;\n      }\n    }\n    return name + \".nar\";\n  },\n  checksum: function(file, cb){\n    var hash;\n    hash = crypto.createHash('sha1');\n    return fs.createReadStream(\n    file).on('data', (function(it){\n      return hash.update(it);\n    })).on('end', function(){\n      return cb(null, hash.digest('hex'));\n    }).on('error', cb);\n  },\n  rename: function(orig, filename, cb){\n    var base;\n    base = dirname(\n    orig);\n    return fs.rename(orig, join(base, filename), cb);\n  },\n  copy: function(file, dest, cb){\n    var filename;\n    filename = basename(\n    file);\n    dest = join(dest, filename);\n    return fs.createReadStream(\n    file).pipe(fs.createWriteStream(dest)).on('close', function(){\n      return cb(null, dest);\n    }).on('error', cb);\n  },\n  copyBinary: function(file, dest, cb){\n    return _.copy(file, dest, function(err, output){\n      var name;\n      if (err) {\n        return cb(\n        err);\n      }\n      if ((name = basename(\n      file)) !== 'node') {\n        return _.rename(output = join(dirname(\n        output), name), 'node', function(err){\n          if (err) {\n            return cb(\n            err);\n          }\n          return cb(null, output);\n        });\n      } else {\n        return cb(null, output);\n      }\n    });\n  },\n  winBinaryScript: function(path){\n    path = normalize(\n    path);\n    return \"@ECHO OFF\\n@IF EXIST \\\"%~dp0\\\\node.exe\\\" (\\n  \\\"%~dp0\\\\node.exe\\\" \\\"\" + path + \"\\\" %*\\n) ELSE (\\n  node \\\"\" + path + \"\\\" %*\\n)\";\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/status.js":"// Generated by LiveScript 1.3.1\nmodule.exports = {\n  100: 'Continue',\n  101: 'Switching Protocols',\n  200: 'OK',\n  201: 'Created',\n  202: 'Accepted',\n  203: 'Non-Authoritative Information',\n  204: 'No Content',\n  205: 'Reset Content',\n  206: 'Partial Content',\n  300: 'Multiple Choices',\n  301: 'Moved Permanently',\n  302: 'Found',\n  303: 'See Other',\n  304: 'Not Modified',\n  305: 'Use Proxy',\n  307: 'Temporary Redirect',\n  400: 'Bad Request',\n  401: 'Unauthorized',\n  402: 'Payment Required',\n  403: 'Forbidden',\n  404: 'Not Found',\n  405: 'Method Not Allowed',\n  406: 'Not Acceptable',\n  407: 'Proxy Authentication Required',\n  408: 'Request Time-out',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length Required',\n  412: 'Precondition Failed',\n  413: 'Request Entity Too Large',\n  414: 'Request-URI Too Large',\n  415: 'Unsupported Media Type',\n  416: 'Requested Range not Satisfiable',\n  417: 'Expectation Failed',\n  429: 'Too Many Requests',\n  500: 'Internal Server Error',\n  501: 'Not Implemented',\n  502: 'Bad Gateway',\n  503: 'Service Unavailable',\n  504: 'Gateway Time-out',\n  505: 'HTTP Version not Supported',\n  CONTINUE: 100,\n  SWITCHING_PROTOCOLS: 101,\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NON_AUTHORITATIVE_INFORMATION: 203,\n  NO_CONTENT: 204,\n  RESET_CONTENT: 205,\n  PARTIAL_CONTENT: 206,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  USE_PROXY: 305,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  REQUEST_ENTITY_TOO_LARGE: 413,\n  REQUEST_URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  REQUESTED_RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  TOO_MANY_REQUESTS: 429,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/extract.js":"// Generated by LiveScript 1.3.1\nvar fw, utils, unpack, EventEmitter, findup, ref$, symlinkSync, chmodSync, readdirSync, join, dirname, normalize, sep, relative, next, copy, isFile, isDir, tmpdir, rm, mk, read, write, clone, addExtension, isExecutable, executableMsg, isWin, isString, isObject, winBinaryScript, extract, apply, mkDirs, normalizePath;\nfw = require('fw');\nutils = require('./utils');\nunpack = require('./unpack');\nEventEmitter = require('events').EventEmitter;\nfindup = require('findup-sync');\nref$ = require('fs'), symlinkSync = ref$.symlinkSync, chmodSync = ref$.chmodSync, readdirSync = ref$.readdirSync;\nref$ = require('path'), join = ref$.join, dirname = ref$.dirname, normalize = ref$.normalize, sep = ref$.sep, relative = ref$.relative;\nnext = utils.next, copy = utils.copy, isFile = utils.isFile, isDir = utils.isDir, tmpdir = utils.tmpdir, rm = utils.rm, mk = utils.mk, read = utils.read, write = utils.write, clone = utils.clone, addExtension = utils.addExtension, isExecutable = utils.isExecutable, executableMsg = utils.executableMsg, isWin = utils.isWin, isString = utils.isString, isObject = utils.isObject, winBinaryScript = utils.winBinaryScript;\nmodule.exports = extract = function(options){\n  var ref$, path, dest, tmpdir, emitter, errored, clean, cleanError, onEnd, onEntry, onMsg, onError, extractor, extractorFn, copyBinFn, createSymlinks, getExtractFiles, extractArchives, copyNarJson, setExecutionPerms, extractNar, extractTasks, doExtract, e;\n  options == null && (options = {});\n  ref$ = options = apply(\n  options), path = ref$.path, dest = ref$.dest, tmpdir = ref$.tmpdir;\n  emitter = new EventEmitter;\n  errored = false;\n  clean = function(){\n    try {\n      return rm(tmpdir);\n    } catch (e$) {}\n  };\n  cleanError = function(){\n    clean();\n    try {\n      if (dest !== process.cwd()) {\n        return rm(dest);\n      }\n    } catch (e$) {}\n  };\n  onEnd = function(){\n    clean();\n    if (!errored) {\n      return emitter.emit('end', options);\n    }\n  };\n  onEntry = function(entry){\n    if (entry) {\n      return emitter.emit('entry', entry);\n    }\n  };\n  onMsg = function(msg){\n    if (msg) {\n      return emitter.emit('message', msg);\n    }\n  };\n  onError = function(err){\n    cleanError();\n    if (!errored) {\n      emitter.emit('error', err);\n    }\n    return errored = true;\n  };\n  extractor = function(options, type){\n    return function(done){\n      var path, dest, createLink, processGlobalBinaries, extractEnd;\n      path = options.path, dest = options.dest;\n      if (/\\/@[a-z0-9]+\\//i.test(path)) {\n        path = path.replace(/@[a-z0-9]+\\//i, '');\n      }\n      if (!isFile(\n      path)) {\n        return onError(\n        new Error('The given path is not a file'));\n      }\n      if (isExecutable(\n      path)) {\n        return onError(\n        executableMsg(\n        path));\n      }\n      createLink = function(name, path){\n        var binPath, root, binDir, binFile;\n        binPath = join(dest, path);\n        if (isFile(\n        binPath)) {\n          if (root = findup('package.json', {\n            cwd: dirname(\n            binPath)\n          })) {\n            binDir = join(dirname(\n            root), '../../../', 'bin');\n            binFile = join(binDir, name);\n            if (!isDir(\n            binDir)) {\n              mk(binDir);\n            }\n            if (isWin) {\n              return write(binFile + \".cmd\", winBinaryScript(\n              binPath));\n            } else {\n              return symlinkSync(binPath, binFile);\n            }\n          }\n        }\n      };\n      processGlobalBinaries = function(pkg){\n        var bin, name, path, own$ = {}.hasOwnProperty, results$ = [];\n        bin = pkg.bin;\n        if (isString(\n        bin)) {\n          return createLink(pkg.name, bin);\n        } else if (isObject(\n        bin)) {\n          for (name in bin) if (own$.call(bin, name)) {\n            path = bin[name];\n            if (path) {\n              results$.push(createLink(name, path));\n            }\n          }\n          return results$;\n        }\n      };\n      extractEnd = function(){\n        var pkg;\n        if (type === 'global-dependency') {\n          pkg = read(\n          join(dest, 'package.json'));\n          if (pkg) {\n            processGlobalBinaries(\n            pkg);\n          }\n        }\n        return done();\n      };\n      return function(){\n        if (!isDir(\n        dest)) {\n          mk(\n          dest);\n        }\n        return unpack(\n        options).on('error', onError).on('entry', onEntry).on('end', extractEnd);\n      }();\n    };\n  };\n  extractorFn = function(it){\n    var options;\n    options = {\n      gzip: false,\n      path: join(tmpdir, it.archive),\n      dest: normalizePath(\n      join(dest, it.dest)),\n      checksum: it.checksum\n    };\n    return extractor(options, it.type);\n  };\n  copyBinFn = function(options){\n    return function(done){\n      var origin, target;\n      origin = join(tmpdir, options.archive);\n      target = normalizePath(\n      join(dest, options.dest));\n      if (!isDir(\n      target)) {\n        mk(target);\n      }\n      return copy(origin, target, done);\n    };\n  };\n  createSymlinks = function(files){\n    return function(done){\n      var links, base, cwd, name, link, own$ = {}.hasOwnProperty;\n      links = files.links;\n      base = join(dest, 'node_modules', '.bin');\n      cwd = process.cwd();\n      mk(\n      base);\n      process.chdir(\n      base);\n      for (name in links) if (own$.call(links, name)) {\n        link = links[name];\n        if (isFile(\n        link) && !isFile(\n        name)) {\n          symlinkSync(link, name);\n        }\n      }\n      process.chdir(\n      cwd);\n      return done();\n    };\n  };\n  getExtractFiles = function(nar){\n    var tasks, links;\n    tasks = [];\n    links = null;\n    nar.files.forEach(function(it){\n      if (it.type !== 'binaries') {\n        emitter.emit('archive', it);\n      }\n      if (it.type === 'binary') {\n        return tasks.push(\n        copyBinFn(\n        it));\n      } else if (it.type === 'binaries') {\n        return links = it;\n      } else {\n        return tasks.push(\n        extractorFn(\n        it));\n      }\n    });\n    if (links) {\n      tasks.push(\n      createSymlinks(\n      links));\n    }\n    return tasks;\n  };\n  extractArchives = function(done){\n    var nar;\n    nar = read(\n    join(tmpdir, '.nar.json'));\n    emitter.emit('info', nar);\n    return fw.series(getExtractFiles(\n    nar), done);\n  };\n  copyNarJson = function(done){\n    var origin;\n    origin = join(tmpdir, '.nar.json');\n    return copy(origin, dest, function(err){\n      if (err) {\n        return onError(\n        err);\n      }\n      return done();\n    });\n  };\n  setExecutionPerms = function(){\n    var depsBinDir, binDir;\n    depsBinDir = join(dest, 'node_modules', '.bin');\n    binDir = join(dest, 'bin');\n    return [binDir, depsBinDir].filter((function(it){\n      return isDir(it);\n    })).forEach(function(dir){\n      return readdirSync(\n      dir).forEach(function(it){\n        try {\n          return chmodSync(join(dir, it), '775');\n        } catch (e$) {}\n      });\n    });\n  };\n  extractNar = function(){\n    var config;\n    config = clone(\n    options);\n    config.dest = tmpdir;\n    return extractor(\n    config);\n  }();\n  extractTasks = function(){\n    return fw.series([extractNar, extractArchives, copyNarJson], function(err){\n      if (err) {\n        return onError(\n        err);\n      }\n      setExecutionPerms();\n      return onEnd();\n    });\n  };\n  doExtract = function(){\n    return next(function(){\n      mkDirs(dest, tmpdir);\n      emitter.emit('start', dest);\n      return extractTasks();\n    });\n  };\n  try {\n    doExtract();\n  } catch (e$) {\n    e = e$;\n    onError(\n    e);\n  }\n  return emitter;\n};\napply = function(options){\n  return {\n    gzip: true,\n    tmpdir: tmpdir(),\n    dest: options.dest || process.cwd(),\n    path: addExtension(\n    options.path)\n  };\n};\nmkDirs = function(dest, tmpdir){\n  if (!isDir(\n  dest)) {\n    mk(dest);\n  }\n  if (!isDir(\n  tmpdir)) {\n    return mk(tmpdir);\n  }\n};\nnormalizePath = function(path){\n  if (path) {\n    return path.replace(new RegExp('\\\\\\\\', 'g'), '/');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/unpack.js":"// Generated by LiveScript 1.3.1\nvar fs, tar, createGunzip, EventEmitter, _, next, unpack, apply;\nfs = require('fs');\ntar = require('tar');\ncreateGunzip = require('zlib').createGunzip;\nEventEmitter = require('events').EventEmitter;\n_ = require('./utils'), next = _.next;\nmodule.exports = unpack = function(options){\n  var ref$, path, checksum, errored, emitter, onEnd, onEntry, onError, doExtract, extractArchive, extractGzip, extractNormal, calculateChecksum;\n  options == null && (options = {});\n  ref$ = apply(\n  options), path = ref$.path, checksum = ref$.checksum;\n  errored = false;\n  emitter = new EventEmitter;\n  onEnd = function(){\n    if (!errored) {\n      return emitter.emit('end');\n    }\n  };\n  onEntry = function(entry){\n    if (entry) {\n      return emitter.emit('entry', entry);\n    }\n  };\n  onError = function(err){\n    if (err && !/unexpected eof/.test(err.message)) {\n      if (!errored) {\n        emitter.emit('error', err);\n      }\n      return errored = true;\n    }\n  };\n  doExtract = function(){\n    return next(function(){\n      var extractor;\n      extractor = extractArchive(options);\n      if (checksum) {\n        return calculateChecksum(checksum, path, extractor);\n      } else {\n        return extractor();\n      }\n    });\n  };\n  extractArchive = function(options){\n    return function(){\n      var dest, gzip, stream;\n      dest = options.dest, gzip = options.gzip;\n      if (!dest) {\n        dest = process.cwd();\n      }\n      stream = fs.createReadStream(path);\n      stream.on('error', onError);\n      if (gzip) {\n        return extractGzip(stream, dest);\n      } else {\n        return extractNormal(stream, dest);\n      }\n    };\n  };\n  extractGzip = function(stream, dest){\n    var gzstream;\n    gzstream = stream.pipe(createGunzip());\n    gzstream.on('error', onError);\n    return extractNormal(gzstream, dest);\n  };\n  extractNormal = function(stream, dest){\n    var extract;\n    extract = tar.Extract({\n      path: dest\n    });\n    extract.on('entry', onEntry);\n    return stream.pipe(extract).on('error', onError).on('end', onEnd);\n  };\n  calculateChecksum = function(hash, file, cb){\n    return _.checksum(file, function(err, nhash){\n      if (err) {\n        return onError(\n        err);\n      }\n      if (hash === nhash) {\n        return cb();\n      } else {\n        return onError(\n        new Error(\"Checksum verification failed: \" + nhash));\n      }\n    });\n  };\n  doExtract();\n  return emitter;\n};\napply = function(options){\n  return {\n    dest: options.dest || process.cwd(),\n    gzip: options.gzip || false,\n    path: options.path || null,\n    checksum: options.checksum || null\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/download.js":"// Generated by LiveScript 1.3.1\nvar fs, request, utils, parse, ref$, join, dirname, EventEmitter, version, progress, next, env, isWin, isArray, once, platform, arch, mk, rm, exists, clone, extend, discoverPkg, httpStatus, headers, download, apply, getFilename, getProxy, discoverAuth;\nfs = require('fs');\nrequest = require('request');\nutils = require('./utils');\nparse = require('url').parse;\nref$ = require('path'), join = ref$.join, dirname = ref$.dirname;\nEventEmitter = require('events').EventEmitter;\nversion = require('../package.json').version;\nprogress = require('request-progress');\nnext = utils.next, env = utils.env, isWin = utils.isWin, isArray = utils.isArray, once = utils.once, platform = utils.platform, arch = utils.arch, mk = utils.mk, rm = utils.rm, exists = utils.exists, clone = utils.clone, extend = utils.extend, discoverPkg = utils.discoverPkg, httpStatus = utils.httpStatus;\nheaders = {\n  'User-Agent': \"node nar \" + version + \" (\" + platform + \"-\" + arch + \")\"\n};\nmodule.exports = download = function(options){\n  var ref$, url, dest, filename, auth, emitter, output, errored, createDest, clean, onError, onDownload, onEnd, onProgress, handler, doDownload, e;\n  ref$ = options = apply(\n  options), url = ref$.url, dest = ref$.dest, filename = ref$.filename, auth = ref$.auth;\n  emitter = new EventEmitter;\n  output = join(dest, filename);\n  errored = false;\n  createDest = function(){\n    if (!exists(\n    dest)) {\n      return mk(dest);\n    }\n  };\n  clean = function(){\n    try {\n      return rm(output);\n    } catch (e$) {}\n  };\n  onError = once(function(err, code){\n    errored = true;\n    clean();\n    if (err) {\n      return emitter.emit('error', err, code);\n    }\n  });\n  onDownload = function(){\n    return emitter.emit(\n    'download');\n  };\n  onEnd = once(function(){\n    if (!errored) {\n      return emitter.emit('end', output);\n    }\n  });\n  onProgress = function(it){\n    return emitter.emit('progress', it);\n  };\n  handler = function(err, res, data){\n    if (err) {\n      return onError(\n      err);\n    } else if (res.statusCode >= 400) {\n      return onError(new Error(\"Invalid response code: \" + httpStatus(res.statusCode)), res.statusCode);\n    } else if (!data) {\n      return onError(\n      new Error('Empty response'));\n    }\n  };\n  doDownload = function(){\n    return next(function(){\n      var stream, http;\n      onDownload();\n      createDest();\n      stream = fs.createWriteStream(\n      output);\n      stream.on('error', onError);\n      http = request(options, handler);\n      http.on('error', onError);\n      return progress(http).on('progress', onProgress).pipe(stream).on('close', onEnd);\n    });\n  };\n  try {\n    doDownload();\n  } catch (e$) {\n    e = e$;\n    onError(\n    e);\n  }\n  return emitter;\n};\napply = function(options){\n  return {\n    url: options.url,\n    auth: discoverAuth(\n    options.auth),\n    filename: options.filename || getFilename(\n    options.url),\n    dest: options.dest || process.cwd(),\n    timeout: options.timeout || 10000,\n    strictSSL: options.strictSSL || false,\n    proxy: options.proxy || getProxy(),\n    headers: extend(clone(\n    headers), options.headers)\n  };\n};\ngetFilename = function(url){\n  var file;\n  if (url) {\n    file = parse(url).pathname.split('/').slice(-1).pop();\n    if (!file) {\n      file = 'archive.nar';\n    }\n  } else {\n    file = 'archive.nar';\n  }\n  return file;\n};\ngetProxy = function(){\n  return env(\n  'http_proxy');\n};\ndiscoverAuth = function(auth){\n  var user, password;\n  if (auth) {\n    user = auth.user, password = auth.password;\n  }\n  if (!user) {\n    user = env(\n    'HTTP_USER');\n  }\n  if (!password) {\n    password = env(\n    'HTTP_PASSWORD');\n  }\n  if (user && password) {\n    return {\n      user: user,\n      password: password\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/list.js":"// Generated by LiveScript 1.3.1\nvar fs, tar, createGunzip, EventEmitter, ref$, next, isFile, addExtension, isExecutable, executableMsg, list, apply;\nfs = require('fs');\ntar = require('tar');\ncreateGunzip = require('zlib').createGunzip;\nEventEmitter = require('events').EventEmitter;\nref$ = require('./utils'), next = ref$.next, isFile = ref$.isFile, addExtension = ref$.addExtension, isExecutable = ref$.isExecutable, executableMsg = ref$.executableMsg;\nmodule.exports = list = function(options){\n  var ref$, path, gzip, emitter, ended, error, files, onError, onEnd, onEntry, onListener, parse;\n  ref$ = apply(\n  options), path = ref$.path, gzip = ref$.gzip;\n  emitter = new EventEmitter;\n  ended = false;\n  error = false;\n  files = [];\n  onError = function(err){\n    error = err;\n    return emitter.emit('error', err);\n  };\n  onEnd = function(){\n    ended = true;\n    return emitter.emit('end', files);\n  };\n  onEntry = function(entry){\n    files.push(\n    entry);\n    return emitter.emit('entry', entry);\n  };\n  onListener = function(name, fn){\n    switch (name) {\n    case 'error':\n      if (error) {\n        return fn(\n        error);\n      }\n      break;\n    case 'end':\n      if (ended) {\n        return fn(\n        files);\n      }\n    }\n  };\n  parse = function(){\n    return next(function(){\n      var nar, entries, entryReader, emitEntries, parse, stream;\n      nar = null;\n      entries = {};\n      if (!isFile(\n      path)) {\n        return onError(\n        new Error('The given path is not a file'));\n      }\n      if (isExecutable(\n      path)) {\n        return onError(\n        executableMsg(\n        path));\n      }\n      entryReader = function(entry){\n        var data;\n        data = '';\n        if (/\\.nar\\.json$/.test(entry.path)) {\n          entry.on('data', function(it){\n            return data += it.toString();\n          });\n          return entry.on('end', function(){\n            return nar = JSON.parse(\n            data);\n          });\n        } else {\n          return entries[entry.path] = entry, entries;\n        }\n      };\n      emitEntries = function(){\n        emitter.emit('info', nar);\n        return nar.files.forEach(function(file){\n          return onEntry(\n          {\n            archive: file.archive,\n            type: file.type,\n            dest: file.dest,\n            size: entries[file.archive] ? entries[file.archive].size : void 8,\n            props: entries[file.archive] ? entries[file.archive].props : void 8\n          });\n        });\n      };\n      parse = tar.Parse();\n      parse.on('error', onError);\n      parse.on('entry', entryReader);\n      parse.on('end', function(){\n        if (!nar) {\n          return onError(\n          new Error('Invalid nar file'));\n        }\n        emitEntries();\n        return onEnd();\n      });\n      stream = fs.createReadStream(\n      path);\n      stream.on('error', onError);\n      if (gzip) {\n        stream = stream.pipe(createGunzip());\n      }\n      return stream.pipe(parse);\n    });\n  };\n  emitter.on('newListener', onListener);\n  parse();\n  return emitter;\n};\napply = function(options){\n  return {\n    gzip: true,\n    path: addExtension(\n    options.path)\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/create.js":"// Generated by LiveScript 1.3.1\nvar fs, fw, path, pack, utils, resolveTree, arrayUnique, resolve, EventEmitter, ref$, dirname, basename, join, normalize, read, rm, tmpdir, clone, extend, copyBinary, keys, archiveName, isObject, isFile, isDir, isLink, isString, mk, stringify, vals, exists, checksum, lines, next, isArray, now, replaceEnvVars, discoverPkg, handleExit, once, isWin, resolvePkgPath, BINDIR, narFile, ext, ignoredFiles, ignoreFiles, defaults, create, writeConfig, narManifest, includeFilesPatterns, getIgnoredFiles, isValid, outputFile, getFilename, applyPkgOptions, apply, getBinaryPath, getModulePath, matchDependencies, getResolveOptions;\nfs = require('fs');\nfw = require('fw');\npath = require('path');\npack = require('./pack');\nutils = require('./utils');\nresolveTree = require('resolve-tree');\narrayUnique = require('array-unique');\nresolve = require('requireg').resolve;\nEventEmitter = require('events').EventEmitter;\nref$ = require('path'), dirname = ref$.dirname, basename = ref$.basename, join = ref$.join, normalize = ref$.normalize;\nread = utils.read, rm = utils.rm, tmpdir = utils.tmpdir, clone = utils.clone, extend = utils.extend, copyBinary = utils.copyBinary, keys = utils.keys, archiveName = utils.archiveName, isObject = utils.isObject, isFile = utils.isFile, isDir = utils.isDir, isLink = utils.isLink, isString = utils.isString, mk = utils.mk, stringify = utils.stringify, vals = utils.vals, exists = utils.exists, checksum = utils.checksum, lines = utils.lines, next = utils.next, isArray = utils.isArray, now = utils.now, replaceEnvVars = utils.replaceEnvVars, discoverPkg = utils.discoverPkg, handleExit = utils.handleExit, once = utils.once, isWin = utils.isWin, resolvePkgPath = utils.resolvePkgPath;\nBINDIR = '_modules-bindir';\nnarFile = '.nar.json';\next = 'nar';\nignoredFiles = ['!node_modules/**'];\nignoreFiles = ['.gitignore', '.npmignore', '.buildignore', '.narignore'];\ndefaults = {\n  path: null,\n  binary: false,\n  binaryPath: process.execPath,\n  dependencies: true,\n  devDependencies: false,\n  peerDependencies: true,\n  globalDependencies: null,\n  patterns: null,\n  ignoreFiles: true\n};\nmodule.exports = create = function(options){\n  var errored, emitter, pkgPath, pkg, name, tmpPath, baseDir, file, output, clean, cleanError, onError, onEntry, onEnd, doCreate, compressAll, compressPkg, compressDependencies, e;\n  errored = false;\n  emitter = new EventEmitter;\n  options = apply(\n  options);\n  pkgPath = options.path;\n  if (pkgPath) {\n    pkg = read(\n    pkgPath);\n  }\n  if (pkg) {\n    options = applyPkgOptions(options, pkg);\n  }\n  if (!pkg) {\n    throw new Error('Cannot find package.json');\n  }\n  name = pkg.name || 'unnamed';\n  tmpPath = tmpdir(name);\n  options.base = baseDir = dirname(\n  pkgPath);\n  file = getFilename(options, pkg);\n  output = outputFile(file, options.dest);\n  clean = function(){\n    emitter.emit('message', 'Cleaning temporary directories');\n    try {\n      return rm(tmpPath);\n    } catch (e$) {}\n  };\n  cleanError = function(){\n    clean();\n    try {\n      return rm(output);\n    } catch (e$) {}\n  };\n  onError = once(function(err){\n    cleanError();\n    if (!errored) {\n      emitter.emit('error', err);\n    }\n    return errored = true;\n  });\n  onEntry = function(it){\n    if (it) {\n      return emitter.emit('entry', it);\n    }\n  };\n  onEnd = function(){\n    clean();\n    if (!errored) {\n      return emitter.emit('end', output);\n    }\n  };\n  doCreate = function(){\n    return next(function(){\n      var narConfig, deps, basePkg, all, doCompression, onCompress;\n      handleExit(\n      cleanError);\n      narConfig = narManifest(name, pkg);\n      emitter.emit('start', narConfig);\n      emitter.emit('info', narConfig);\n      deps = function(done){\n        return compressDependencies(tmpPath, baseDir, function(err, files){\n          if (err) {\n            return onError(\n            err);\n          }\n          if (files) {\n            narConfig.files = narConfig.files.concat(files);\n          }\n          return done();\n        });\n      };\n      basePkg = function(done){\n        var config;\n        config = {\n          dest: tmpPath,\n          base: baseDir,\n          name: name,\n          patterns: options.patterns\n        };\n        return compressPkg(config, function(it){\n          narConfig.files.push(\n          it);\n          return done();\n        });\n      };\n      all = function(done){\n        return compressAll(narConfig, done);\n      };\n      doCompression = function(done){\n        mk(\n        tmpPath);\n        return fw.series([deps, basePkg, all], done);\n      };\n      onCompress = function(err){\n        if (err) {\n          return onError(\n          err);\n        }\n        return onEnd();\n      };\n      return doCompression(\n      onCompress);\n    });\n  };\n  compressAll = function(narConfig, cb){\n    var config, packAll, saveConfig, exec, addBinary;\n    config = {\n      name: file,\n      dest: options.dest,\n      patterns: ['*.tar', narFile],\n      src: tmpPath,\n      ext: 'nar',\n      gzip: true\n    };\n    packAll = function(done){\n      return pack(config).on('error', done).on('entry', onEntry).on('end', function(){\n        return done();\n      });\n    };\n    saveConfig = function(done){\n      return writeConfig(narConfig, tmpPath, done);\n    };\n    exec = function(){\n      return fw.series([saveConfig, packAll], cb);\n    };\n    addBinary = function(){\n      var binaryPath, pkgInfo;\n      binaryPath = options.binaryPath;\n      if (!isFile(\n      binaryPath)) {\n        return onError(\n        new Error(\"Binary path do not exists: \" + binaryPath));\n      }\n      pkgInfo = {\n        name: 'node',\n        archive: 'node',\n        dest: '.node/bin',\n        type: 'binary'\n      };\n      emitter.emit('archive', pkgInfo);\n      return copyBinary(binaryPath, tmpPath, function(err, file){\n        if (err) {\n          return onError(\n          new Error(\"Error while copying the binary: \" + err));\n        }\n        config.patterns.push(\n        basename(\n        file));\n        onEntry(\n        {\n          name: pkgInfo.archive,\n          type: pkgInfo.type,\n          size: '10485760',\n          sourcePath: binaryPath\n        });\n        return checksum(file, function(err, hash){\n          pkgInfo.checksum = hash;\n          narConfig.files.push(\n          pkgInfo);\n          return exec();\n        });\n      });\n    };\n    if (options.binary && !options.executable) {\n      narConfig.binary = true;\n      return addBinary();\n    } else {\n      return exec();\n    }\n  };\n  compressPkg = function(config, cb){\n    var ref$, dest, base, name, patterns, archive, pkgInfo, onPackEnd;\n    ref$ = config = clone(\n    config), dest = ref$.dest, base = ref$.base, name = ref$.name, patterns = ref$.patterns;\n    if (!(patterns.length > 0)) {\n      patterns.push(\"**\");\n    }\n    config.patterns = patterns.concat(includeFilesPatterns(base, options.ignoreFiles));\n    config.src = base;\n    archive = name.replace('/', '-');\n    pkgInfo = {\n      name: name,\n      archive: archive + \".tar\",\n      dest: '.',\n      type: 'package'\n    };\n    emitter.emit('archive', pkgInfo);\n    onPackEnd = function(pkg){\n      return checksum(pkg.path, function(err, hash){\n        pkgInfo.checksum = hash;\n        return cb(pkgInfo);\n      });\n    };\n    return pack(config).on('error', function(it){\n      throw it;\n    }).on('entry', onEntry).on('end', onPackEnd);\n  };\n  compressDependencies = function(dest, base, cb){\n    var files, globals, addBinDirectory, pkgManifestExists, getPkgPath, mapPkgData, calculateChecksum, definePkgBindirInfo, definePkgDependencyInfo, definePkgInfo, doPack, compressDepPkgs, findGlobal, processGlobal, processDeps, resolveOptionalDep, processOptionalDeps, dependenciesList, sharedDependencies, list, ref$, tree, global;\n    files = [];\n    globals = [];\n    addBinDirectory = function(it){\n      var binDir, links;\n      binDir = join(base, getModulePath(\n      '.bin'));\n      if (isDir(\n      binDir)) {\n        links = {};\n        fs.readdirSync(\n        binDir).filter(function(it){\n          return !/^\\./.test(it);\n        }).filter(function(it){\n          return it !== 'Thumbs.db';\n        }).forEach(function(file){\n          var linkPath;\n          if (isWin) {\n            return links[file] = join(join(binDir, '..', file, 'bin', file), file), links;\n          } else {\n            linkPath = join(binDir, file);\n            if (isLink(\n            linkPath)) {\n              return links[file] = fs.readlinkSync(\n              linkPath), links;\n            }\n          }\n        });\n        return it.push(\n        {\n          name: BINDIR,\n          src: binDir,\n          dest: dest,\n          links: links\n        });\n      }\n    };\n    pkgManifestExists = function(path){\n      return isFile(\n      join(path, 'package.json'));\n    };\n    getPkgPath = function(name){\n      var path;\n      path = join(base, getModulePath(\n      name));\n      if (!pkgManifestExists(\n      path)) {\n        throw new Error(\"Missing required dependency in node_modules: \" + name + \"\\nRun: npm install\");\n      }\n      return path;\n    };\n    mapPkgData = function(it){\n      return it.map(function(it){\n        return {\n          name: it,\n          dest: dest,\n          src: getPkgPath(\n          it)\n        };\n      });\n    };\n    calculateChecksum = function(pkgPath, pkgInfo, done){\n      return checksum(pkgPath, function(err, hash){\n        if (err) {\n          throw new Error(\"Error while calculating checksum for package \" + pkgInfo.name);\n        }\n        pkgInfo.checksum = hash;\n        pkgInfo.dest = pkgInfo.dest;\n        return done(null, pkgInfo);\n      });\n    };\n    definePkgBindirInfo = function(pkgInfo, pkg){\n      pkgInfo.type = 'binaries';\n      pkgInfo.links = pkg.links;\n      files.push(\n      pkgInfo);\n      return pkgInfo;\n    };\n    definePkgDependencyInfo = function(pkgInfo, pkg, done){\n      if (globals.indexOf(\n      pkg.name) !== -1) {\n        pkgInfo.dest = \".node/lib/node/\" + pkg.name;\n        pkgInfo.type = 'global-dependency';\n      } else {\n        pkgInfo.dest = getModulePath(\n        pkg.name);\n        pkgInfo.type = 'dependency';\n      }\n      emitter.emit('archive', pkgInfo);\n      return calculateChecksum(pkg.path, pkgInfo, function(err, pkgInfo){\n        files.push(\n        pkgInfo);\n        return done.apply(this, arguments);\n      });\n    };\n    definePkgInfo = function(pkg, done){\n      var pkgInfo;\n      pkgInfo = {\n        name: pkg.name\n      };\n      if (pkg.file) {\n        pkgInfo.archive = pkg.file;\n      }\n      if (pkg.name === BINDIR) {\n        return done(null, definePkgBindirInfo(pkgInfo, pkg));\n      } else {\n        return definePkgDependencyInfo(pkgInfo, pkg, done);\n      }\n    };\n    doPack = function(pkg, done){\n      if (pkg.name === BINDIR) {\n        return done(null, pkg);\n      } else {\n        return pack(\n        pkg).on('error', done).on('entry', onEntry).on('end', function(it){\n          return done(null, it);\n        });\n      }\n    };\n    compressDepPkgs = function(pkgs, done){\n      return fw.map(pkgs, doPack, function(err, results){\n        if (err) {\n          return done(\n          err);\n        }\n        return fw.map(results, definePkgInfo, done);\n      });\n    };\n    findGlobal = function(name){\n      var module, jsonPath, pkg, src;\n      module = resolve(\n      name);\n      if (!module) {\n        throw new Error(\"Cannot find global dependency: \" + name);\n      }\n      if (jsonPath = discoverPkg(\n      dirname(\n      module))) {\n        if (pkg = read(\n        jsonPath)) {\n          globals.push(\n          pkg.name);\n          src = dirname(\n          jsonPath);\n          return {\n            name: pkg.name,\n            dest: dest,\n            src: src\n          };\n        }\n      }\n    };\n    processGlobal = function(globals){\n      return vals(\n      globals).filter(isValid).map(findGlobal);\n    };\n    processDeps = function(deps){\n      deps = vals(\n      deps).filter(isValid).map(mapPkgData).filter(isValid);\n      if (deps.length) {\n        addBinDirectory(\n        deps[0]);\n      }\n      return deps;\n    };\n    resolveOptionalDep = function(name){\n      var src, e;\n      try {\n        src = getPkgPath(\n        name);\n      } catch (e$) {\n        e = e$;\n        return null;\n      }\n      return {\n        name: name,\n        dest: dest,\n        src: src,\n        optional: true\n      };\n    };\n    processOptionalDeps = function(deps){\n      return deps.filter(isValid).map(resolveOptionalDep).filter(function(it){\n        return it;\n      });\n    };\n    dependenciesList = function(){\n      var ref$, run, dev, peer, optional, global, list;\n      ref$ = matchDependencies(options, pkg), run = ref$.run, dev = ref$.dev, peer = ref$.peer, optional = ref$.optional, global = ref$.global;\n      list = processDeps(\n      {\n        run: run,\n        dev: dev,\n        peer: peer\n      });\n      if (optional) {\n        list = list.concat([processOptionalDeps(\n        optional)]);\n      }\n      if (global) {\n        list = list.concat([processGlobal(\n        global)]);\n      }\n      return list;\n    };\n    sharedDependencies = function(deps, options, cb){\n      var binaries, list, names, opts;\n      deps = deps || [];\n      binaries = deps.filter(function(pkg){\n        return pkg.name === BINDIR;\n      }).shift();\n      list = deps.filter(function(pkg){\n        return pkg.name !== BINDIR;\n      });\n      names = list.map(function(pkg){\n        return pkg.name;\n      });\n      if (!names.length) {\n        cb(null, deps);\n      }\n      opts = getResolveOptions(\n      options);\n      return resolveTree.packages(names, opts, function(err, tree){\n        var treeNames, buf;\n        if (err) {\n          return cb(\n          err);\n        }\n        treeNames = resolveTree.flattenMap(tree, 'root').filter(function(it){\n          return path.join(opts.basedir, 'node_modules', path.basename(it)) === it;\n        }).map(function(it){\n          return path.basename(it);\n        });\n        buf = arrayUnique(\n        names.concat(\n        treeNames));\n        buf = mapPkgData(\n        buf);\n        if (binaries) {\n          buf = buf.concat(\n          binaries);\n        }\n        return cb(null, buf);\n      });\n    };\n    ref$ = list = dependenciesList(), tree = ref$[0], global = ref$[1];\n    if (!list.length) {\n      cb();\n    }\n    tree = tree || [];\n    return sharedDependencies(tree, options, function(err, deps){\n      if (err) {\n        return cb(err);\n      }\n      list[0] = deps;\n      return fw.each(list, compressDepPkgs, (function(it){\n        return cb(it, files);\n      }));\n    });\n  };\n  try {\n    doCreate();\n  } catch (e$) {\n    e = e$;\n    onError(\n    e);\n  }\n  return emitter;\n};\nwriteConfig = function(config, tmpdir, cb){\n  var file, data;\n  file = join(tmpdir, narFile);\n  data = stringify(\n  config);\n  return fs.writeFile(file, data, cb);\n};\nnarManifest = function(name, pkg){\n  var platform, arch, version;\n  platform = process.platform, arch = process.arch, version = process.version;\n  return {\n    name: name,\n    time: now(),\n    binary: false,\n    info: {\n      platform: platform,\n      arch: arch,\n      version: version\n    },\n    manifest: pkg,\n    files: []\n  };\n};\nincludeFilesPatterns = function(dir, ignore){\n  var patterns;\n  patterns = clone(\n  ignoredFiles);\n  if (ignore) {\n    patterns = patterns.concat(getIgnoredFiles(\n    dir));\n  }\n  return patterns;\n};\ngetIgnoredFiles = function(dir){\n  var patterns, files, ignored;\n  patterns = [];\n  files = ignoreFiles.map((function(it){\n    return join(dir, it);\n  })).filter((function(it){\n    return exists(it);\n  }));\n  if (files.length > 1) {\n    files = files.slice(-1);\n  }\n  if (files.length) {\n    ignored = lines(\n    read(\n    files[0]));\n    if (isArray(\n    ignored)) {\n      patterns = ignored.filter(function(it){\n        return it;\n      }).map(function(it){\n        if (isDir(\n        join(dir, it))) {\n          return it + \"/**\";\n        } else {\n          return it;\n        }\n      }).map(function(it){\n        return \"!\" + it.trim();\n      });\n    }\n  }\n  patterns = patterns.concat(ignoreFiles.map(function(it){\n    return \"!\" + it;\n  }));\n  return patterns;\n};\nisValid = function(it){\n  return it && it.length;\n};\noutputFile = function(file, dir){\n  return join(dir, file + \".nar\");\n};\ngetFilename = function(options, pkg){\n  var file, binary, name;\n  pkg == null && (pkg = {});\n  file = options.file, binary = options.binary;\n  if (file) {\n    name = file.replace(/\\.[a-z0-9]$/i, '');\n  } else {\n    name = pkg.name || 'unnamed';\n    if (pkg.version) {\n      name += \"-\" + pkg.version;\n    }\n  }\n  if (name[0] === '@') {\n    name = name.replace(/^@[a-z0-9]+\\//i, '');\n  }\n  if (binary && !options.executable) {\n    name += \"-\" + process.platform + \"-\" + process.arch;\n  }\n  return name;\n};\napplyPkgOptions = function(options, pkg){\n  return extend(options, pkg.archive);\n};\napply = function(options){\n  var pkgPath;\n  options = extend(clone(\n  defaults), options);\n  options.patterns || (options.patterns = []);\n  if (options.path) {\n    pkgPath = resolvePkgPath(\n    options.path);\n  } else {\n    pkgPath = process.cwd();\n  }\n  options.binaryPath = getBinaryPath(\n  options);\n  options.path = discoverPkg(\n  pkgPath);\n  if (!options.dest) {\n    options.dest = process.cwd();\n  }\n  return options;\n};\ngetBinaryPath = function(options){\n  var binary;\n  binary = options.binaryPath;\n  if (process.env.NAR_BINARY) {\n    binary = process.env.NAR_BINARY;\n  }\n  return replaceEnvVars(\n  normalize(\n  binary));\n};\ngetModulePath = function(it){\n  if (it === BINDIR) {\n    it = '.bin';\n  }\n  return join('node_modules', it);\n};\nmatchDependencies = function(options, pkg){\n  var dependencies, devDependencies, peerDependencies, optionalDependencies, globalDependencies, deps;\n  dependencies = options.dependencies, devDependencies = options.devDependencies, peerDependencies = options.peerDependencies, optionalDependencies = options.optionalDependencies, globalDependencies = options.globalDependencies;\n  deps = {};\n  if (dependencies) {\n    deps.run = keys(\n    pkg.dependencies);\n  }\n  if (devDependencies) {\n    deps.dev = keys(\n    pkg.devDependencies);\n  }\n  if (peerDependencies) {\n    deps.peer = keys(\n    pkg.peerDependencies);\n  }\n  if (dependencies || optionalDependencies) {\n    deps.optional = keys(\n    pkg.optionalDependencies || {});\n  }\n  if (isArray(\n  globalDependencies)) {\n    deps.global = globalDependencies;\n  }\n  return deps;\n};\ngetResolveOptions = function(options){\n  var basedir, opts;\n  basedir = path.dirname(\n  options.path);\n  opts = {\n    lookups: ['dependencies', 'optionalDependencies'],\n    basedir: basedir\n  };\n  return opts;\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/pack.js":"// Generated by LiveScript 1.3.1\nvar fs, path, archiver, tmpdir, createGzip, EventEmitter, ref$, checksum, exists, next, isDir, zlibOptions, ignoredFiles, pack, normalizeName, apply;\nfs = require('fs');\npath = require('path');\narchiver = require('archiver');\ntmpdir = require('os').tmpdir;\ncreateGzip = require('zlib').createGzip;\nEventEmitter = require('events').EventEmitter;\nref$ = require('./utils'), checksum = ref$.checksum, exists = ref$.exists, next = ref$.next, isDir = ref$.isDir;\nzlibOptions = {\n  level: 1\n};\nignoredFiles = ['!.DS_Store', '!Thumbs.db', '!ehthumbs.db', '!Desktop.ini', '!$RECYCLE.BIN/', '!.AppleDouble', '!.LSOverride', '!.Trashes', '!.apdisk', '!.AppleDB', '!.nar'];\nmodule.exports = pack = function(options){\n  var ref$, name, src, dest, patterns, ext, emitter, errored, onEnd, onEntry, onError, createStream, createTar, calculateChecksum, doPack;\n  options == null && (options = {});\n  ref$ = options = apply(\n  options), name = ref$.name, src = ref$.src, dest = ref$.dest, patterns = ref$.patterns, ext = ref$.ext;\n  emitter = new EventEmitter;\n  errored = false;\n  onEnd = function(data){\n    if (!errored) {\n      return emitter.emit('end', data);\n    }\n  };\n  onEntry = function(entry){\n    if (entry) {\n      return emitter.emit('entry', entry);\n    }\n  };\n  onError = function(err){\n    if (!errored) {\n      emitter.emit('error', err);\n    }\n    return errored = true;\n  };\n  createStream = function(file, cb){\n    return fs.createWriteStream(file).on('error', onError).on('close', cb);\n  };\n  createTar = function(stream, options){\n    var src, gzip, patterns, tar, include, res$, i$, len$, pattern, ignore;\n    src = options.src, gzip = options.gzip, patterns = options.patterns;\n    tar = archiver('tar', zlibOptions);\n    tar.on('entry', onEntry);\n    tar.on('error', onError);\n    res$ = [];\n    for (i$ = 0, len$ = patterns.length; i$ < len$; ++i$) {\n      pattern = patterns[i$];\n      if (pattern && pattern[0] !== '!') {\n        res$.push(pattern);\n      }\n    }\n    include = res$;\n    res$ = [];\n    for (i$ = 0, len$ = patterns.length; i$ < len$; ++i$) {\n      pattern = patterns[i$];\n      if (pattern && pattern[0] === '!') {\n        res$.push(pattern.slice(1));\n      }\n    }\n    ignore = res$;\n    for (i$ = 0, len$ = include.length; i$ < len$; ++i$) {\n      pattern = include[i$];\n      tar.glob(pattern, {\n        expand: true,\n        cwd: src,\n        ignore: ignore\n      }, {\n        name: '.'\n      });\n    }\n    if (gzip) {\n      tar.pipe(\n      createGzip()).pipe(\n      stream);\n    } else {\n      tar.pipe(\n      stream);\n    }\n    return tar.finalize();\n  };\n  calculateChecksum = function(file, data){\n    return function(){\n      return checksum(file, function(err, hash){\n        if (err) {\n          return onError(\n          err);\n        }\n        data.checksum = hash;\n        return onEnd(\n        data);\n      });\n    };\n  };\n  doPack = function(){\n    return next(function(){\n      var file, filePath, data, cb;\n      if (!exists(\n      src)) {\n        return onError(\n        new Error('source path do not exists'));\n      }\n      if (!isDir(\n      dest)) {\n        return onError(\n        new Error('destination path is not a directory'));\n      }\n      file = normalizeName(\n      name) + \".\" + ext;\n      filePath = path.join(dest, file);\n      data = {\n        name: name,\n        file: file,\n        path: filePath\n      };\n      cb = calculateChecksum(filePath, data);\n      return createTar(createStream(filePath, cb), options);\n    });\n  };\n  doPack();\n  return emitter;\n};\nnormalizeName = function(name){\n  if (~name.indexOf('@')) {\n    name = name.replace('/', '-');\n  }\n  return name;\n};\napply = function(options){\n  return {\n    src: options.src || process.cwd(),\n    ext: options.ext || 'tar',\n    name: options.name || 'unnamed',\n    dest: options.dest || tmpdir(\n    options.name),\n    gzip: options.gzip || false,\n    patterns: (options.patterns || ['**', '.*']).concat(ignoredFiles)\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/install.js":"// Generated by LiveScript 1.3.1\nvar utils, extract, download, ncp, join, resolve, EventEmitter, ref$, symlinkSync, chmodSync, rm, mk, next, write, read, isWin, isString, isObject, isArray, replaceEnvVars, isFile, isUrl, isDir, clone, extend, tmpdir, discoverPkg, winBinaryScript, defaults, install, apply, save, writeJson;\nutils = require('./utils');\nextract = require('./extract');\ndownload = require('./download');\nncp = require('ncp').ncp;\njoin = require('path').join;\nresolve = require('requireg').resolve;\nEventEmitter = require('events').EventEmitter;\nref$ = require('fs'), symlinkSync = ref$.symlinkSync, chmodSync = ref$.chmodSync;\nrm = utils.rm, mk = utils.mk, next = utils.next, write = utils.write, read = utils.read, isWin = utils.isWin, isString = utils.isString, isObject = utils.isObject, isArray = utils.isArray, replaceEnvVars = utils.replaceEnvVars, isFile = utils.isFile, isUrl = utils.isUrl, isDir = utils.isDir, clone = utils.clone, extend = utils.extend, tmpdir = utils.tmpdir, discoverPkg = utils.discoverPkg, winBinaryScript = utils.winBinaryScript;\ndefaults = {\n  gzip: true,\n  dest: null,\n  clean: true,\n  save: false,\n  saveDev: false,\n  savePeer: false,\n  global: false\n};\nmodule.exports = install = function(options){\n  var ref$, path, url, dest, clean, global, emitter, output, pkgInfo, tmp, cleanDir, onError, onEntry, onDownload, onProgress, onArchive, onDownloadEnd, onEnd, onExtract, getInstallPath, copy, createBinDir, setExecutionPerms, createLink, createBinary, processBinaries, extractor, downloader, doInstall, e;\n  ref$ = options = apply(\n  options), path = ref$.path, url = ref$.url, dest = ref$.dest, clean = ref$.clean, global = ref$.global;\n  emitter = new EventEmitter;\n  output = null;\n  pkgInfo = {};\n  tmp = tmpdir(\n  path);\n  cleanDir = function(){\n    try {\n      if (isDir(\n      tmp)) {\n        rm(tmp);\n      }\n      if (clean && output) {\n        return rm(output);\n      }\n    } catch (e$) {}\n  };\n  onError = function(err, code, cmd){\n    cleanDir();\n    return emitter.emit('error', err, code, cmd);\n  };\n  onEntry = function(entry){\n    if (entry) {\n      return emitter.emit('entry', entry);\n    }\n  };\n  onDownload = function(){\n    return emitter.emit('download');\n  };\n  onProgress = function(it){\n    return emitter.emit('progress', it);\n  };\n  onArchive = function(it){\n    pkgInfo = it;\n    return emitter.emit('archive', it);\n  };\n  onDownloadEnd = function(it){\n    return emitter.emit('downloadEnd', it);\n  };\n  onEnd = function(output){\n    save(\n    options);\n    cleanDir();\n    return emitter.emit('end', output, options);\n  };\n  onExtract = function(it){\n    if (options.dest === tmp) {\n      return copy();\n    } else {\n      return onEnd(\n      it);\n    }\n  };\n  getInstallPath = function(){\n    var dest;\n    if (global) {\n      dest = resolve('npm');\n      if (dest) {\n        return dest = join(dest, '../../../', pkgInfo.name || 'pkg');\n      } else {\n        return onError(\n        new Error('Cannot resolve global installation path'));\n      }\n    } else {\n      return dest = join(process.cwd(), 'node_modules', pkgInfo.name || 'pkg');\n    }\n  };\n  copy = function(){\n    var dest;\n    dest = getInstallPath();\n    if (!isDir(\n    dest)) {\n      mk(dest);\n    }\n    return ncp(tmp, dest, function(err){\n      if (err) {\n        return onError(\n        err);\n      }\n      processBinaries(\n      dest);\n      return onEnd(\n      {\n        dest: dest\n      });\n    });\n  };\n  createBinDir = function(dir){\n    if (!isDir(\n    dir)) {\n      return mk(dir);\n    }\n  };\n  setExecutionPerms = function(file){\n    try {\n      return chmodSync(file, '775');\n    } catch (e$) {}\n  };\n  createLink = function(binPath, dest){\n    if (isWin) {\n      return write(dest + \".cmd\", winBinaryScript(\n      binPath));\n    } else {\n      symlinkSync(binPath, dest);\n      return setExecutionPerms(\n      dest);\n    }\n  };\n  createBinary = function(dest, path, name){\n    var binPath, root;\n    binPath = join(dest, path);\n    if (isFile(\n    binPath)) {\n      if (global) {\n        root = join(dest, '../../../', 'bin');\n        createBinDir(root);\n        return createLink(binPath, join(root, name));\n      } else {\n        root = join(dest, '../', '.bin');\n        createBinDir(root);\n        return createLink(binPath, join(root, name));\n      }\n    }\n  };\n  processBinaries = function(dest){\n    var pkg, bin, name, path, own$ = {}.hasOwnProperty, results$ = [];\n    pkg = join(dest, 'package.json');\n    if (isFile(\n    pkg)) {\n      bin = (pkg = read(\n      pkg)).bin;\n      if (isString(\n      bin)) {\n        return createBinary(dest, bin, pkg.name);\n      } else if (isObject(\n      bin)) {\n        for (name in bin) if (own$.call(bin, name)) {\n          path = bin[name];\n          if (path) {\n            results$.push(createBinary(dest, path, name));\n          }\n        }\n        return results$;\n      }\n    }\n  };\n  extractor = function(path){\n    emitter.emit(\n    'start');\n    options.path = path;\n    options.dest || (options.dest = tmp);\n    return extract(\n    options).on('error', onError).on('entry', onEntry).on('archive', onArchive).on('end', onExtract);\n  };\n  downloader = function(){\n    if (!url) {\n      options.url = path;\n    }\n    return download(\n    options).on('download', onDownload).on('progress', onProgress).on('error', onError).on('end', function(it){\n      output = it;\n      onDownloadEnd(\n      output);\n      return extractor(\n      output);\n    });\n  };\n  doInstall = function(){\n    return next(function(){\n      if (url || isUrl(\n      path)) {\n        return downloader();\n      } else {\n        return extractor(\n        path);\n      }\n    });\n  };\n  try {\n    doInstall();\n  } catch (e$) {\n    e = e$;\n    onError(\n    \"Cannot install: \" + e);\n  }\n  return emitter;\n};\napply = function(options){\n  return extend(clone(\n  defaults), options);\n};\nsave = function(options){\n  var save, saveDev, savePeer, pkgPath, pkg, pkgInfo, ref$, name, version;\n  save = options.save, saveDev = options.saveDev, savePeer = options.savePeer;\n  pkgPath = discoverPkg();\n  if (pkgPath) {\n    pkg = read(\n    pkgPath);\n    pkgInfo = read(\n    join(options.dest, '.nar.json'));\n    ref$ = pkgInfo.manifest, name = ref$.name, version = ref$.version;\n    if (name && version) {\n      if (save) {\n        pkg.dependencies || (pkg.dependencies = {});\n        if (!pkg.dependencies[name]) {\n          pkg.dependencies[name] = \"~\" + version;\n        }\n      }\n      if (saveDev) {\n        pkg.devDependencies || (pkg.devDependencies = {});\n        if (!pkg.devDependencies[name]) {\n          pkg.devDependencies[name] = \"~\" + version;\n        }\n      }\n      if (savePeer) {\n        pkg.peerDependencies || (pkg.peerDependencies = {});\n        if (!pkg.peerDependencies[name]) {\n          pkg.peerDependencies[name] = \"~\" + version;\n        }\n      }\n    }\n  }\n  return writeJson(pkgPath, pkg);\n};\nwriteJson = function(path, pkg){\n  return write(path, JSON.stringify(pkg, null, 2));\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/create-exec.js":"// Generated by LiveScript 1.3.1\nvar fs, fw, path, pack, utils, unpack, create, download, arrayUnique, resolveTree, ncp, exec, EventEmitter, ref$, dirname, join, basename, relative, rm, mk, isWin, tmpdir, copyBinary, rename, exists, once, isFile, extend, handleExit, arch, discoverPkg, resolvePkgPath, script, supportedPlatforms, supportedArchs, supportedVersions, copyOpts, apply, findIndex, matchVersion, sameNodeBinary, setOs, setArch, setNode;\nfs = require('fs');\nfw = require('fw');\npath = require('path');\npack = require('./pack');\nutils = require('./utils');\nunpack = require('./unpack');\ncreate = require('./create');\ndownload = require('./download');\narrayUnique = require('array-unique');\nresolveTree = require('resolve-tree');\nncp = require('ncp').ncp;\nexec = require('child_process').exec;\nEventEmitter = require('events').EventEmitter;\nref$ = require('path'), dirname = ref$.dirname, join = ref$.join, basename = ref$.basename, relative = ref$.relative;\nrm = utils.rm, mk = utils.mk, isWin = utils.isWin, tmpdir = utils.tmpdir, copyBinary = utils.copyBinary, rename = utils.rename, exists = utils.exists, once = utils.once, isFile = utils.isFile, extend = utils.extend, handleExit = utils.handleExit, arch = utils.arch, discoverPkg = utils.discoverPkg, resolvePkgPath = utils.resolvePkgPath;\nscript = join(__dirname, '..', 'scripts/run.sh');\nsupportedPlatforms = ['linux', 'darwin', 'sunos'];\nsupportedArchs = ['x86', 'x64', 'armv7l'];\nsupportedVersions = [/^0.(8|9|10|11|12).[0-9]+$/, /^[0-9].[0-9].[0-9]+$/];\ncopyOpts = {\n  stopOnErr: false,\n  clobber: true\n};\nmodule.exports = function(options){\n  var emitter, dest, tmpPath, tmpDownload, nodeBinary, clean, onError, onDownloadError, onEntry, onEnd, onCreateEnd, onProgress, onDownload, onDownloadEnd, getBinaryType, createExecutable;\n  emitter = new EventEmitter;\n  options = apply(\n  options);\n  dest = options.dest || process.cwd();\n  tmpPath = tmpdir();\n  tmpDownload = null;\n  options.dest = tmpPath;\n  nodeBinary = null;\n  clean = function(){\n    emitter.emit('message', 'Cleaning temporary directories');\n    try {\n      rm(\n      tmpPath);\n      if (tmpDownload) {\n        return rm(\n        tmpDownload);\n      }\n    } catch (e$) {}\n  };\n  onError = once(function(err){\n    clean();\n    return emitter.emit('error', err);\n  });\n  onDownloadError = function(err){\n    return onError(\n    err);\n  };\n  onEntry = function(it){\n    if (it) {\n      return emitter.emit('entry', it);\n    }\n  };\n  onEnd = function(it){\n    clean();\n    return emitter.emit('end', it);\n  };\n  onCreateEnd = function(narPath){\n    return createExecutable(\n    narPath);\n  };\n  onProgress = function(status){\n    return emitter.emit('progress', status);\n  };\n  onDownload = function(){\n    return emitter.emit(\n    'download');\n  };\n  onDownloadEnd = function(it){\n    return emitter.emit('downloadEnd', it);\n  };\n  getBinaryType = function(){\n    var os, arch;\n    os = options.os, arch = options.arch;\n    return os + \"-\" + arch;\n  };\n  createExecutable = function(nar){\n    var narFile, narPath, narOutput, cleanExec, copyNodeBinary, copyDirectory, copyNarPkg, createTarball, createBinary, generate, extractBinary, getDownloadUrl, downloadBinary;\n    narFile = basename(nar, '.nar');\n    narPath = join(dest, narFile) + '.run';\n    narOutput = join(dest, narFile) + (\"-\" + getBinaryType() + \".nar\");\n    cleanExec = function(){\n      rm(\n      narPath);\n      return clean();\n    };\n    copyNodeBinary = function(done){\n      var binDir;\n      binDir = join(tmpPath, 'bin');\n      mk(\n      binDir);\n      return copyBinary(nodeBinary || process.execPath, binDir, done);\n    };\n    copyDirectory = function(dest){\n      return function(dir, next){\n        var name, orig, pkgDest;\n        name = basename(\n        dir);\n        orig = join(dest, name);\n        pkgDest = join(dest, name);\n        return fs.exists(orig, function(exists){\n          if (exists) {\n            return next();\n          }\n          return fs.exists(pkgDest, function(exists){\n            if (exists) {\n              return next();\n            }\n            mk(\n            pkgDest);\n            return ncp(dir, pkgDest, copyOpts, next);\n          });\n        });\n      };\n    };\n    copyNarPkg = function(done){\n      var narDest, narPath, narManifest, doCopy;\n      narDest = join(tmpPath, 'nar');\n      narPath = join(__dirname, '..');\n      narManifest = require(join(narPath, 'package.json'));\n      doCopy = function(paths, done){\n        return ncp(narPath, narDest, copyOpts, function(err){\n          var depsDest;\n          if (err) {\n            return done(\n            err);\n          }\n          depsDest = join(narDest, 'node_modules');\n          return fw.each(paths, copyDirectory(\n          depsDest), done);\n        });\n      };\n      return resolveTree.manifest(narManifest, {\n        basedir: narPath\n      }, function(err, tree){\n        var paths, rootPaths, parentPaths;\n        if (err) {\n          return cb(err);\n        }\n        paths = arrayUnique(\n        resolveTree.flattenMap(tree, 'root'));\n        rootPaths = paths.filter(function(it){\n          return join(options.base, 'node_modules', basename(it)) === it;\n        });\n        parentPaths = arrayUnique(\n        paths.filter(function(it){\n          return rootPaths.indexOf(\n          it) === -1;\n        }).filter(function(it){\n          return new RegExp(\"^\" + narPath).test(it) === false;\n        }).map(function(it){\n          return relative(join(options.base, 'node_modules'), it).split('/').shift();\n        }).map(function(it){\n          return join(options.base, 'node_modules', it);\n        }).filter(function(it){\n          return rootPaths.indexOf(\n          it) === -1;\n        }));\n        return doCopy(rootPaths.concat(parentPaths), done);\n      });\n    };\n    createTarball = function(done){\n      var config;\n      config = {\n        name: basename(nar, '.nar'),\n        dest: dest,\n        patterns: ['**'],\n        src: tmpPath,\n        ext: 'run',\n        gzip: true\n      };\n      return pack(\n      config).on('error', done).on('entry', onEntry).on('end', function(){\n        return done();\n      });\n    };\n    createBinary = function(done){\n      var cmd;\n      cmd = isWin ? 'type' : 'cat';\n      return exec(cmd + \" \\\"\" + script + \"\\\" \\\"\" + narPath + \"\\\" > \\\"\" + narOutput + \"\\\"\", function(err){\n        if (err) {\n          return done(\n          err);\n        }\n        if (!/^win/.test(\n        process.platform)) {\n          return fs.chmod(narOutput, '775', done);\n        } else {\n          return done();\n        }\n      });\n    };\n    generate = function(){\n      emitter.emit(\n      'generate');\n      return fw.parallel([copyNodeBinary, copyNarPkg], function(err){\n        if (err) {\n          return onError(\n          new Error('cannot copy files to temporal directory: ' + err));\n        }\n        return fw.series([createTarball, createBinary], function(err){\n          if (err) {\n            return onError(\n            new Error(\"cannot create the executable due to error: \" + (err.messsage || err)));\n          }\n          cleanExec();\n          return emitter.emit('end', narOutput);\n        });\n      });\n    };\n    extractBinary = function(options){\n      options.gzip = true;\n      return unpack(\n      options).on('error', onError).on('end', function(){\n        nodeBinary = join(options.dest, options.name, 'bin', 'node');\n        return generate();\n      });\n    };\n    getDownloadUrl = function(engine){\n      engine = engine === 'node' ? 'nodejs' : engine;\n      return \"https://\" + engine + \".org/dist\";\n    };\n    downloadBinary = function(){\n      var node, io, engine, version, name, url, dest;\n      node = options.node, io = options.io;\n      engine = io ? 'iojs' : 'node';\n      version = io || node;\n      name = engine + \"-\" + version + \"-\" + getBinaryType();\n      url = getDownloadUrl(\n      engine) + \"/\" + version + \"/\" + name + \".tar.gz\";\n      dest = tmpDownload = tmpdir();\n      return download(\n      {\n        url: url,\n        dest: dest,\n        proxy: options.proxy\n      }).on('download', onDownload).on('progress', onProgress).on('error', onDownloadError).on('end', function(it){\n        onDownloadEnd(\n        it);\n        return extractBinary(\n        {\n          path: it,\n          dest: dest,\n          name: name\n        });\n      });\n    };\n    if (!sameNodeBinary(\n    options)) {\n      return downloadBinary();\n    } else {\n      return generate();\n    }\n  };\n  if (isWin && options.os === 'win32') {\n    return onError(\n    new Error('Windows do not support nar executables. Use --os <linux|darwin|sunos>'));\n  }\n  mk(tmpPath);\n  handleExit(\n  clean);\n  create(\n  options).on('error', onError).on('entry', onEntry).on('end', onCreateEnd).on('start', function(){\n    return emitter.emit(\n    'start');\n  }).on('archive', function(it){\n    return emitter.emit('archive', it);\n  });\n  return emitter;\n};\napply = function(options){\n  var pkgPath;\n  setOs(\n  options);\n  setArch(\n  options);\n  setNode(\n  options);\n  options.executable = true;\n  if (options.path) {\n    pkgPath = resolvePkgPath(\n    options.path);\n  } else {\n    pkgPath = process.cwd();\n  }\n  options.path = discoverPkg(\n  pkgPath);\n  if (/\\.json$/i.test(pkgPath)) {\n    options.base = dirname(\n    pkgPath);\n  } else {\n    options.base = pkgPath;\n  }\n  return options;\n};\nfindIndex = function(arr, item){\n  return arr.indexOf(item) !== -1;\n};\nmatchVersion = function(version){\n  return supportedVersions.filter(function(it){\n    return it.test(version);\n  }).length !== 0;\n};\nsameNodeBinary = function(options){\n  var os, arch, node, io;\n  os = options.os, arch = options.arch, node = options.node, io = options.io;\n  if (io) {\n    node = io;\n  }\n  return os === process.platform && arch === process.arch && node === process.version;\n};\nsetOs = function(options){\n  var os;\n  os = options.os;\n  if (os) {\n    if (findIndex(supportedPlatforms, os)) {\n      return options.os = os, options;\n    } else {\n      throw new Error(\"Invalid OS platform '\" + os + \"'. Only \" + supportedPlatforms.join(', ') + \" are supported\");\n    }\n  } else {\n    return options.os = process.platform, options;\n  }\n};\nsetArch = function(options){\n  var arch;\n  arch = options.arch;\n  if (arch) {\n    if (findIndex(supportedArchs, arch)) {\n      return options.arch = arch, options;\n    } else {\n      throw new Error(\"Invalid architecture '\" + arch + \"'. Only x86, x64 and armv7l are supported\");\n    }\n  } else {\n    return options.arch = process.arch, options;\n  }\n};\nsetNode = function(options){\n  var node, io;\n  node = options.node, io = options.io;\n  if (node) {\n    if (node === 'latest') {\n      return options.node = 'latest', options;\n    } else if (matchVersion(\n    node)) {\n      return options.node = \"v\" + node, options;\n    } else {\n      throw new Error(\"Invalid node version '\" + node + \"'\");\n    }\n  } else if (io) {\n    if (io === 'latest') {\n      return options.io = 'latest', options;\n    } else if (matchVersion(\n    io)) {\n      return options.io = \"v\" + io, options;\n    } else {\n      throw new Error(\"Invalid io.js version '\" + io + \"'\");\n    }\n  } else {\n    return options.node = process.version, options;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/cli.js":"// Generated by LiveScript 1.3.1\nvar path, colors, nar, echo, program, cmdMap, help, map;\npath = require('path');\ncolors = require('colors');\nnar = require('./nar');\necho = require('./utils').echo;\nprogram = require('commander');\ncmdMap = {\n  e: 'extract',\n  c: 'create',\n  x: 'run',\n  l: 'list',\n  i: 'install',\n  g: 'get',\n  start: 'run',\n  build: 'create',\n  download: 'get',\n  show: 'list'\n};\nmodule.exports.parse = function(it){\n  return program.parse(\n  map(\n  it));\n};\nprogram.version(nar.VERSION);\nprogram.command('help').action(function(){\n  return help(\n  echo());\n}).description('\\n  Output usage information');\nprogram.on('--help', help = function(){\n  return echo('  Usage examples:\\n\\n    $ nar create\\n    $ nar run app.nar\\n    $ nar extract app.nar -o some/dir\\n    $ nar list app.nar\\n    $ nar install app.nar --save\\n    $ nar get http://server.net/app.nar\\n\\n  Command specific help:\\n\\n    $ nar <command> --help\\n\\t');\n});\n['create', 'extract', 'run', 'list', 'install', 'get'].forEach(function(it){\n  return require(\n  \"./commands/\" + it);\n});\nmap = function(args){\n  var cmd, alias, ref$, value, own$ = {}.hasOwnProperty;\n  cmd = args[2];\n  for (alias in ref$ = cmdMap) if (own$.call(ref$, alias)) {\n    value = ref$[alias];\n    if (alias === cmd) {\n      args[2] = value;\n    }\n  }\n  return args;\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/commands/create.js":"// Generated by LiveScript 1.3.1\nvar path, nar, common, utils, program, echo, exit, onEntry, onError, createBar, onProgress, updateBar, onDownloadEnd, exists, isDir, isFile, isString, options, create, normalize, apply, getMode;\npath = require('path');\nnar = require('../nar');\ncommon = require('./common');\nutils = require('../utils');\nprogram = require('commander');\necho = common.echo, exit = common.exit, onEntry = common.onEntry, onError = common.onError, createBar = common.createBar, onProgress = common.onProgress, updateBar = common.updateBar, onDownloadEnd = common.onDownloadEnd;\nexists = utils.exists, isDir = utils.isDir, isFile = utils.isFile, isString = utils.isString;\noptions = ['dependencies', 'devDependencies', 'peerDependencies', 'globalDependencies', 'patterns', 'binary', 'binaryPath', 'os', 'arch', 'node', 'proxy', 'io'];\nprogram.command('create [path]').description('\\n  Create a nar archive').usage('<path> [options]').option('-o, --output <path>', 'Output directory. Default to current directory').option('-f, --file <name>', 'Define the archive file name').option('-r, --dependencies', 'Include dependencies').option('-x, --dev-dependencies', 'Include development dependencies').option('-p, --peer-dependencies', 'Include peer dependencies').option('-g, --global-dependencies <names>', 'Include global dependencies, comma separated').option('-n, --omit-dependencies', 'Create archive without embed any type of dependencies').option('-i, --patterns <patterns>', 'Glob patterns to use for files include/exclude, comma separated').option('-b, --binary', 'Include node binary in the archive').option('-e, --executable', 'Create archive as self executable binary').option('-l, --binary-path <path>', 'Custom node binary to embed into the archive').option('-s, --os <name>', 'node.js OS binary platform to embed. Default to current OS').option('-a, --arch <name>', 'node.js OS binary architecture to embed. Default to ' + process.arch).option('-q, --node <version>', 'node.js binary version to embed. Default to ' + process.version).option('-t, --io <version>', 'io.js binary version to embed').option('--proxy <url>', 'Proxy server URL to use to download binaries').option('-d, --debug', 'Enable debug mode. More information will be shown').option('-v, --verbose', 'Enable verbose mode. A lot of information will be shown').on('--help', function(){\n  return echo('  Usage examples:\\n\\n    $ nar create\\n    $ nar create some/dir --debug\\n    $ nar create path/to/package.json -o some/dir\\n    $ nar create --verbose --binary\\n    $ nar create --node 0.12.0\\n    $ nar create --global-dependencies \\'npm,grunt\\' --patterns \\'!.tmp,src/**\\'\\n\\t');\n}).action(function(){\n  return create.apply(this, arguments);\n});\ncreate = function(pkgpath, options){\n  var debug, verbose, output, file, executable, bar, opts, onStart, onDownload, onArchive, onGenerate, onEnd, create, e;\n  debug = options.debug, verbose = options.verbose, output = options.output, file = options.file, executable = options.executable;\n  bar = createBar();\n  opts = {\n    dest: output,\n    file: file\n  };\n  apply(options, opts);\n  if (opts.binaryPath) {\n    opts.binary = true;\n  }\n  if (options.omitDependencies) {\n    opts.dependencies = false;\n    opts.devDependencies = false;\n    opts.peerDependencies = false;\n  }\n  if (pkgpath) {\n    if (!exists(\n    pkgpath)) {\n      exit(1)(\n      'Error: path do not exists');\n    }\n    if (isFile(\n    pkgpath)) {\n      pkgpath = path.dirname(\n      pkgpath);\n    }\n    if (!isDir(\n    pkgpath)) {\n      exit(1)(\n      'Error: path must be a directory');\n    }\n    opts.path = pkgpath;\n  }\n  onStart = function(){\n    return echo(\n    'Creating archive...');\n  };\n  onDownload = function(){\n    return echo(\n    'Downloading binary...');\n  };\n  onArchive = function(it){\n    if (!(debug && verbose)) {\n      return echo(\n      \"Add [\" + it.type.cyan + \"] \" + (it.name || ''));\n    }\n  };\n  onGenerate = function(){\n    return echo(\n    'Generating executable...');\n  };\n  onEnd = function(output){\n    return echo(\n    \"Created in: \" + output);\n  };\n  create = function(){\n    var archive;\n    archive = nar[getMode(\n    executable)](opts).on('start', onStart).on('error', onError(\n    debug)).on('download', onDownload).on('downloadEnd', onDownloadEnd(\n    bar)).on('progress', onProgress(\n    bar)).on('generate', onGenerate).on('end', onEnd);\n    if (debug || verbose) {\n      return archive.on('entry', onEntry(\n      'Add'));\n    } else {\n      return archive.on('archive', onArchive);\n    }\n  };\n  try {\n    return create();\n  } catch (e$) {\n    e = e$;\n    return onError(debug)(\n    e);\n  }\n};\nnormalize = function(type, value){\n  if (type === 'globalDependencies' || type === 'patterns') {\n    return value.split(',').map(function(it){\n      return it.trim();\n    });\n  } else {\n    return value;\n  }\n};\napply = function(args, opts){\n  return options.filter(function(it){\n    return args[it] === true || isString(\n    args[it]);\n  }).forEach(function(it){\n    return opts[it] = normalize(it, args[it]), opts;\n  });\n};\ngetMode = function(exec){\n  if (exec) {\n    return 'createExec';\n  } else {\n    return 'create';\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/commands/common.js":"// Generated by LiveScript 1.3.1\nvar progress, ref$, echo, logError, exit, toKb, isUrl, extend, archiveName, common;\nprogress = require('progress');\nref$ = require('../utils'), echo = ref$.echo, logError = ref$.logError, exit = ref$.exit, toKb = ref$.toKb, isUrl = ref$.isUrl, extend = ref$.extend, archiveName = ref$.archiveName, toKb = ref$.toKb;\ncommon = module.exports = {\n  echo: echo,\n  exit: exit,\n  toKb: toKb,\n  isUrl: isUrl,\n  extend: extend,\n  archiveName: archiveName,\n  createBar: function(){\n    return new progress('[:bar] :percent :etas', {\n      total: 1,\n      width: 30\n    });\n  },\n  updateBar: function(bar){\n    return function(value){\n      bar.curr = value;\n      try {\n        return bar.render();\n      } catch (e$) {}\n    };\n  },\n  onDownload: function(){\n    return echo(\n    'Downloading archive...');\n  },\n  onStart: function(){\n    return echo(\n    \"Reading archive...\");\n  },\n  onProgress: function(bar){\n    return function(state){\n      if (bar.total === 1) {\n        bar.total = state.total;\n        return bar.start = new Date(), bar;\n      } else {\n        return common.updateBar(bar)(\n        state.received);\n      }\n    };\n  },\n  onEntry: function(action){\n    return function(it){\n      return echo(\n      (action + \" [\").green + (toKb(\n      it.size) + \" KB\").cyan + (\"] \" + (it.path || it.name || '')).green);\n    };\n  },\n  onArchive: function(debug, verbose){\n    return function(it){\n      if (!(debug && verbose)) {\n        return echo(\n        \"Extract [\" + it.type.cyan + \"] \" + (it.name || ''));\n      }\n    };\n  },\n  onError: function(debug){\n    return function(err, code){\n      echo(\n      logError(err, debug));\n      return exit(\n      code || 1)();\n    };\n  },\n  onExtract: function(it){\n    return echo(\n    \"Extract [\" + it.type.cyan + \"] \" + (it.name || ''));\n  },\n  onDownloadEnd: function(bar){\n    return function(){\n      return echo(\n      common.updateBar(\n      bar)(\n      bar.total));\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/commands/extract.js":"// Generated by LiveScript 1.3.1\nvar path, nar, common, program, echo, onEntry, onError, onArchive, extract;\npath = require('path');\nnar = require('../nar');\ncommon = require('./common');\nprogram = require('commander');\necho = common.echo, onEntry = common.onEntry, onError = common.onError, onArchive = common.onArchive;\nprogram.command('extract <archive>').description('\\n  Extract archive').usage('<archive> [options]').option('-o, --output <path>', 'Output directory. Default to current directory').option('-d, --debug', 'Enable debug mode. More information will be shown').option('-v, --verbose', 'Enable verbose mode. A lot of information will be shown').on('--help', function(){\n  return echo('  Usage examples:\\n\\n    $ nar extract\\n    $ nar extract app.nar\\n    $ nar extract app.nar -o some/dir\\n    $ nar extract app.nar --debug\\n\\t');\n}).action(function(){\n  return extract.apply(this, arguments);\n});\nextract = function(archive, options){\n  var debug, verbose, output, opts, onStart, onEnd, extract, e;\n  debug = options.debug, verbose = options.verbose, output = options.output;\n  opts = {\n    path: archive,\n    dest: output\n  };\n  onStart = function(){\n    return echo(\n    \"Reading archive...\");\n  };\n  onEnd = function(it){\n    return echo(\n    \"Extracted in: \" + it.dest);\n  };\n  extract = function(){\n    var archive;\n    archive = nar.extract(opts).on('start', onStart).on('error', onError(\n    debug)).on('end', onEnd);\n    if (debug || verbose) {\n      return archive.on('entry', onEntry(\n      'Extract'));\n    } else {\n      return archive.on('archive', onArchive(debug, verbose));\n    }\n  };\n  try {\n    return extract();\n  } catch (e$) {\n    e = e$;\n    return onError(debug)(\n    \"Cannot extract the archive: \" + e.message);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/commands/run.js":"// Generated by LiveScript 1.3.1\nvar nar, common, program, echo, createBar, onEntry, onArchive, onDownload, onError, onProgress, updateBar, onDownloadEnd, archiveName, run, formatEol;\nnar = require('../nar');\ncommon = require('./common');\nprogram = require('commander');\necho = common.echo, createBar = common.createBar, onEntry = common.onEntry, onArchive = common.onArchive, onDownload = common.onDownload, onError = common.onError, onProgress = common.onProgress, updateBar = common.updateBar, onDownloadEnd = common.onDownloadEnd, archiveName = common.archiveName;\nprogram.command('run <archive>').description('\\n  Run archive files').usage('<archive> [options]').option('-o, --output <path>', 'Output directory').option('-d, --debug', 'Enable debud mode. More information will be shown').option('-v, --verbose', 'Enable verbose  mode. Will output stdout and stderr').option('-as, --args-start <args>', 'Aditional arguments to pass to start command').option('-ap, --args-prestart <args>', 'Aditional arguments to pass to prestart command').option('-as, --args-stop <args>', 'Aditional arguments to pass to stop command').option('-ax, --args-poststop <args>', 'Aditional arguments to pass to poststop command').option('-u, --user <user>', 'HTTP autenticantion user').option('-p, --password <password>', 'HTTP user password').option('--proxy <url>', 'Proxy server URL to use').option('--timeout <number>', 'HTTP request timeout').option('--strict-ssl', 'Enable strict SSL').option('--no-clean', 'Disable app directory clean after exit').option('--no-hooks', 'Disable command hooks').on('--help', function(){\n  return echo('  Usage examples:\\n\\n    $ nar run app.nar\\n    $ nar run app.nar -o some/dir\\n    $ nar run app.nar --args-start \\'--node ${PATH}\\'\\n    $ nar run app.nar --debug --no-hooks\\n    $ nar run http://my.server.net/my-app-0.1.0.nar\\n\\t');\n}).action(function(){\n  return run.apply(this, arguments);\n});\nrun = function(archive, options){\n  var debug, verbose, output, strictSsl, argsStart, argsPrestart, argsStop, argsPoststop, bar, opts, onExtract, onStart, onEnd, onCommand, onInfo, onStdout, onStderr, onExit, run, e;\n  debug = options.debug, verbose = options.verbose, output = options.output, strictSsl = options.strictSsl, argsStart = options.argsStart, argsPrestart = options.argsPrestart, argsStop = options.argsStop, argsPoststop = options.argsPoststop;\n  bar = createBar();\n  opts = {\n    path: archive,\n    dest: output,\n    strictSSL: strictSsl,\n    clean: options.clean,\n    hooks: options.hooks,\n    proxy: options.proxy,\n    timeout: options.timeout,\n    args: {\n      start: argsStart,\n      prestart: argsPrestart,\n      stop: argsStop,\n      poststop: argsPoststop\n    }\n  };\n  if (options.user) {\n    opts.auth = {\n      user: options.user,\n      password: options.password\n    };\n  }\n  onExtract = function(){\n    return echo(\n    \"Extracting files...\");\n  };\n  onStart = function(){\n    return echo(\n    \"Running application...\");\n  };\n  onEnd = function(){\n    return echo(\n    \"Finished\");\n  };\n  onCommand = function(cmd, hook){\n    return echo(\n    \"Run [\".green + hook.cyan + (\"]: \" + cmd).green);\n  };\n  onInfo = function(it){\n    return echo(\n    \"Running \" + archiveName(\n    it));\n  };\n  onStdout = function(out){\n    return echo(\n    (\"> \" + formatEol(\n    out)).green);\n  };\n  onStderr = function(out){\n    return echo(\n    (\"> \" + formatEol(\n    out)).red);\n  };\n  onExit = function(code, hook){\n    return echo(\n    \"End [\".green + hook.cyan + (\"]: exited with code \" + (+code || 0)).green);\n  };\n  run = function(){\n    var archive;\n    archive = nar.run(opts).on('download', onDownload).on('downloadEnd', onDownloadEnd(\n    bar)).on('progress', onProgress(\n    bar)).on('extract', onExtract).on('info', onInfo).on('start', onStart).on('error', onError(\n    debug)).on('end', onEnd).on('command', onCommand).on('stderr', onStderr).on('exit', onExit).on('stdout', onStdout);\n    if (debug || verbose) {\n      if (verbose) {\n        return archive.on('entry', onEntry(\n        'Extract'));\n      }\n    } else {\n      return archive.on('archive', onArchive(debug, verbose));\n    }\n  };\n  try {\n    return run();\n  } catch (e$) {\n    e = e$;\n    return onError(debug)(\n    e);\n  }\n};\nformatEol = function(it){\n  if (it) {\n    return it.replace(/\\n(\\s+)?$/, '').replace(/\\n/g, '\\n> ');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/commands/list.js":"// Generated by LiveScript 1.3.1\nvar path, nar, common, Table, program, join, basename, echo, onError, toKb, archiveName, list, mapEntry;\npath = require('path');\nnar = require('../nar');\ncommon = require('./common');\nTable = require('cli-table');\nprogram = require('commander');\njoin = path.join, basename = path.basename;\necho = common.echo, onError = common.onError, toKb = common.toKb, archiveName = common.archiveName;\nprogram.command('list <archive>').description('\\n  List archive files').usage('<archive> [options]').option('-d, --debug', 'Enable debud mode. More information will be shown').option('--no-table', 'Disable table format output').on('--help', function(){\n  return echo('  Usage examples:\\n\\n    $ nar list app.nar\\n    $ nar list app.nar --no-table\\n\\t');\n}).action(function(){\n  return list.apply(this, arguments);\n});\nlist = function(archive, options){\n  var debug, table, tableList, opts, onInfo, onEntry, onEnd, list, e;\n  debug = options.debug, table = options.table;\n  tableList = new Table({\n    head: ['Name', 'Destination', 'Size', 'Type']\n  });\n  opts = {\n    path: archive\n  };\n  onInfo = function(it){\n    return echo(\n    \"Package: \" + archiveName(\n    it));\n  };\n  onEntry = function(it){\n    var item;\n    if (table) {\n      item = mapEntry(\n      it);\n      if (item) {\n        return tableList.push(\n        item);\n      }\n    } else {\n      return echo(\n      join(it.dest, it.archive) + (\" (\" + toKb(\n      it.size) + \" KB)\").cyan);\n    }\n  };\n  onEnd = function(){\n    if (table) {\n      return echo(\n      tableList.toString());\n    }\n  };\n  list = function(){\n    return nar.list(opts).on('error', onError(\n    debug)).on('info', onInfo).on('entry', onEntry).on('end', onEnd);\n  };\n  try {\n    return list();\n  } catch (e$) {\n    e = e$;\n    return onError(debug)(\n    e);\n  }\n};\nmapEntry = function(it){\n  if (it && it.archive) {\n    return [\n      basename(it.archive, '.tar'), it.dest, toKb(\n      it.size) + ' KB', it.type\n    ];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/commands/install.js":"// Generated by LiveScript 1.3.1\nvar nar, common, program, echo, extend, createBar, onExtract, onDownload, onStart, onError, onProgress, onEntry, updateBar, onDownloadEnd, install;\nnar = require('../nar');\ncommon = require('./common');\nprogram = require('commander');\necho = common.echo, extend = common.extend, createBar = common.createBar, onExtract = common.onExtract, onDownload = common.onDownload, onStart = common.onStart, onError = common.onError, onProgress = common.onProgress, onEntry = common.onEntry, updateBar = common.updateBar, onDownloadEnd = common.onDownloadEnd;\nprogram.command('install <archive>').description('\\n  Install archive').usage('<archive> [options]').option('-o, --output <path>', 'Install directory. Default to node_modules').option('-f, --filename <name>', 'Downloaded filename. Default taken from URL path name').option('-u, --user <user>', 'HTTP autenticantion user').option('-p, --password <password>', 'HTTP user password').option('--proxy <url>', 'Proxy server URL to use').option('--timeout <number>', 'HTTP request timeout').option('--strict-ssl', 'Enable strict SSL').option('-d, --debug', 'Enable debug mode. More information will be shown').option('-v, --verbose', 'Enable verbose mode. A lot of information will be shown').option('-s, --save', 'Save as runtime dependency in package.json').option('-sd, --save-dev', 'Save as development dependency in package.json').option('-sp, --save-peer', 'Save as peer dependency in package.json').option('-g, --global', 'Install as global dependency').option('--clean', 'Remove downloaded file after install').on('--help', function(){\n  return echo('  Usage examples:\\n\\n    $ nar install app.nar --save\\n    $ nar install app.nar -o some/dir\\n    $ nar install app.nar --debug\\n    $ nar install http://server.net/app-0.1.0.nar\\n\\t');\n}).action(function(){\n  return install.apply(this, arguments);\n});\ninstall = function(archive, options){\n  var debug, verbose, output, strictSsl, bar, opts, onStart, onEnd, extract, e;\n  debug = options.debug, verbose = options.verbose, output = options.output, strictSsl = options.strictSsl;\n  bar = createBar();\n  opts = extend(options, {\n    path: archive,\n    dest: output,\n    strictSSL: strictSsl\n  });\n  if (options.user) {\n    opts.auth = {\n      user: options.user,\n      password: options.password\n    };\n  }\n  onStart = function(){\n    return echo(\n    \"Installing archive...\");\n  };\n  onEnd = function(it){\n    return echo(\n    \"Installed in: \" + it.dest);\n  };\n  extract = function(){\n    var installer;\n    installer = nar.install(opts).on('start', onStart).on('progress', onProgress(\n    bar)).on('download', onDownload).on('error', onError(\n    debug)).on('downloadEnd', onDownloadEnd(\n    bar)).on('end', onEnd);\n    if (debug || verbose) {\n      return installer.on('entry', onEntry(\n      'Extract'));\n    }\n  };\n  try {\n    return extract();\n  } catch (e$) {\n    e = e$;\n    return onError(debug)(\n    \"Cannot install the archive: \" + e.message);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nar/node_modules/nar/lib/commands/get.js":"// Generated by LiveScript 1.3.1\nvar progress, nar, common, program, echo, exit, isUrl, createBar, onDownload, onError, onProgress, updateBar, get;\nprogress = require('progress');\nnar = require('../nar');\ncommon = require('./common');\nprogram = require('commander');\necho = common.echo, exit = common.exit, isUrl = common.isUrl, createBar = common.createBar, onDownload = common.onDownload, onError = common.onError, onProgress = common.onProgress, updateBar = common.updateBar;\nprogram.command('get <url>').description('\\n  Download archive from HTTP server').usage('<url> [options]').option('-o, --output <path>', 'Output directory. Default to current directory').option('-f, --filename <name>', 'Downloaded filename. Default taken from URL path name').option('-u, --user <user>', 'HTTP autenticantion user').option('-p, --password <password>', 'HTTP user password').option('--proxy <url>', 'Proxy server URL to use').option('--timeout <number>', 'HTTP request timeout').option('--strict-ssl', 'Enable strict SSL').option('-d, --debug', 'Enable debug mode. More information will be shown').on('--help', function(){\n  return echo('  Usage examples:\\n\\n    $ nar get http://server.net/app.nar\\n    $ nar get http://server.net/app.nar --user john --password pa$s\\n    $ nar get http://server.net/app.nar --proxy http://proxy:3128\\n    $ nar get http://server.net/app.nar --strict-ssl --timeout 60000\\n\\t');\n}).action(function(){\n  return get.apply(this, arguments);\n});\nget = function(url, options){\n  var debug, output, strictSsl, bar, opts, onEnd, download, e;\n  debug = options.debug, output = options.output, strictSsl = options.strictSsl;\n  bar = createBar();\n  opts = {\n    url: url,\n    dest: output,\n    strictSSL: strictSsl,\n    filename: options.filename,\n    timeout: options.timeout,\n    proxy: options.proxy\n  };\n  if (options.user) {\n    opts.auth = {\n      user: options.user,\n      password: options.password\n    };\n  }\n  if (!isUrl(\n  url)) {\n    exit(1)(\n    echo(\"Invalid URL. Cannot download the archive\"));\n  }\n  onEnd = function(it){\n    updateBar(\n    bar)(\n    bar.total);\n    return echo(\n    \"\\nDownloaded in: \" + it);\n  };\n  download = function(){\n    return nar.get(opts).on('download', onDownload).on('progress', onProgress(\n    bar)).on('error', onError(\n    debug)).on('end', onEnd);\n  };\n  try {\n    return download();\n  } catch (e$) {\n    e = e$;\n    return onError(debug)(\n    \"Cannot download the archive: \" + e.message);\n  }\n};\n"}